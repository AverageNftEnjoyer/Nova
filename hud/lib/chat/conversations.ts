import { getActiveUserId } from "@/lib/auth/active-user"

export interface ChatMessage {
  id: string
  role: "user" | "assistant"
  content: string
  createdAt: string
  source?: "hud" | "agent" | "voice"
  sender?: string
}

export interface Conversation {
  id: string
  title: string
  pinned?: boolean
  archived?: boolean
  messages: ChatMessage[]
  createdAt: string
  updatedAt: string
}

type DerivedTitleKind = "generic" | "topic" | "snippet"
const MAX_AUTO_TITLE_WORDS = 3

export const DEFAULT_CONVERSATION_TITLE = "Greetings Exchange"
const GENERIC_CONVERSATION_TITLE_PREFIX = "Greetings Exchange"
const DEFAULT_CONVERSATION_TITLE_PATTERN = /^(new chat|greet(?:ings|igns?) exchange)$/i
const GENERIC_CONVERSATION_TITLE_PATTERN = /^greet(?:ings|igns?) exchange(?:\s-\s.+)?(?:\s\(\d+\))?$/i
const LEGACY_GENERIC_CONVERSATION_TITLE_PATTERN = /^general chat(?:\s-\s.+)?(?:\s\(\d+\))?$/i
const PUNCTUATION_TRIM_PATTERN = /^[\s\p{P}\p{S}]+|[\s\p{P}\p{S}]+$/gu
const LOW_SIGNAL_WORDS = new Set([
  "a",
  "about",
  "afternoon",
  "and",
  "at",
  "bro",
  "buddy",
  "dude",
  "evening",
  "good",
  "hello",
  "hey",
  "hi",
  "morning",
  "nova",
  "ok",
  "okay",
  "plz",
  "please",
  "sup",
  "there",
  "up",
  "what",
  "whats",
  "what's",
  "yo",
  "you",
])
const TITLE_STOPWORDS = new Set([
  "a",
  "an",
  "and",
  "are",
  "can",
  "could",
  "for",
  "from",
  "give",
  "got",
  "had",
  "help",
  "how",
  "i'm",
  "im",
  "i",
  "in",
  "is",
  "it",
  "me",
  "my",
  "need",
  "of",
  "on",
  "please",
  "should",
  "that",
  "the",
  "this",
  "to",
  "us",
  "want",
  "we",
  "with",
  "would",
  "you",
])
const TITLE_CONNECTOR_WORDS = new Set([
  "and",
  "or",
  "of",
  "to",
  "for",
  "in",
  "on",
  "at",
  "by",
  "with",
  "vs",
  "via",
])
const KNOWN_UPPER_WORDS = new Set([
  "ai",
  "api",
  "aws",
  "cpu",
  "css",
  "db",
  "dns",
  "gcp",
  "gpu",
  "html",
  "http",
  "https",
  "ios",
  "js",
  "kpi",
  "llm",
  "ml",
  "nlp",
  "qa",
  "rpc",
  "sdk",
  "seo",
  "sql",
  "ssh",
  "tls",
  "ts",
  "ui",
  "url",
  "ux",
])
const INTENT_NOISE_WORDS = new Set([
  "advice",
  "advise",
  "guidance",
  "help",
  "decide",
  "deciding",
  "debug",
  "bug",
  "error",
  "errors",
  "fix",
  "fixing",
  "fixed",
  "broken",
  "crash",
  "crashing",
  "issue",
  "issues",
  "problem",
  "problems",
  "plan",
  "planning",
  "roadmap",
  "strategy",
  "schedule",
  "summary",
  "summarize",
  "recap",
  "digest",
  "compare",
  "comparison",
  "cost",
  "costs",
  "price",
  "pricing",
  "spend",
  "spending",
  "afford",
  "affordable",
  "worth",
  "value",
  "analysis",
  "analyze",
  "brainstorm",
  "brainstorming",
  "write",
  "writing",
  "rewrite",
  "draft",
  "learn",
  "learning",
  "study",
  "understand",
])
const SUBJECT_PRONOUNS = new Set([
  "i",
  "it",
  "its",
  "itself",
  "me",
  "my",
  "myself",
  "our",
  "ours",
  "ourselves",
  "that",
  "the",
  "their",
  "them",
  "themselves",
  "these",
  "they",
  "this",
  "those",
  "us",
  "we",
  "you",
  "your",
  "yours",
  "yourself",
  "yourselves",
])

function normalizeWhitespace(value: string): string {
  return value.replace(/\s+/g, " ").trim()
}

function normalizeForComparison(value: string): string {
  return normalizeWhitespace(value).toLowerCase()
}

function capAutoGeneratedTitleWords(value: string, maxWords = MAX_AUTO_TITLE_WORDS): string {
  const normalized = normalizeWhitespace(value)
  if (!normalized) return normalized
  if (!Number.isFinite(maxWords) || maxWords < 1) return normalized
  const parts = normalized.split(/\s+/).filter(Boolean)
  if (parts.length <= maxWords) return normalized
  const capped = parts.slice(0, maxWords).join(" ")
  return capped.replace(/[,:;.!?]+$/u, "").trim() || normalized
}

function tokenize(value: string): string[] {
  const matches = value.toLowerCase().match(/[a-z0-9']+/g)
  return matches ? matches.filter(Boolean) : []
}

function stripLeadingAddressing(value: string): string {
  return value
    .replace(/^\s*(hey|hi|hello|yo|sup|good (morning|afternoon|evening))\s+/i, "")
    .replace(/^\s*nova[\s,:-]*/i, "")
    .trim()
}

function cleanSnippetText(value: string): string {
  const stripped = stripLeadingAddressing(value)
  const firstLine = stripped.split("\n")[0] || stripped
  return normalizeWhitespace(firstLine.replace(/[*_`#>~[\]]/g, ""))
}

function isLowSignalText(value: string): boolean {
  const cleaned = normalizeWhitespace(value).replace(PUNCTUATION_TRIM_PATTERN, "")
  if (!cleaned) return true
  const words = tokenize(cleaned)
  if (words.length === 0) return true
  if (words.length <= 6 && words.every((word) => LOW_SIGNAL_WORDS.has(word))) return true
  if (/^(hey|hi|hello|yo|sup|what'?s up|good (morning|afternoon|evening))( nova)?[!.?]*$/i.test(cleaned)) return true
  if (/^(nova)[!.?]*$/i.test(cleaned)) return true
  return false
}

function toTitleCaseWords(value: string): string {
  return value
    .split(" ")
    .filter(Boolean)
    .map((word, index) => {
      const cleaned = word.toLowerCase()
      if (index > 0 && TITLE_CONNECTOR_WORDS.has(cleaned)) return cleaned
      if (KNOWN_UPPER_WORDS.has(cleaned)) {
        return cleaned.toUpperCase()
      }
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    })
    .join(" ")
}

type TitleIntent =
  | "cost"
  | "health"
  | "debug"
  | "plan"
  | "advice"
  | "write"
  | "learn"
  | "compare"
  | "summary"
  | "brainstorm"
  | "analyze"
  | "support"

function detectIntent(text: string): TitleIntent | null {
  if (!text.trim()) return null
  if (/\b(cost|costs|price|prices|pricing|spend|spending|afford|worth|value|expensive|cheap)\b/.test(text)) return "cost"
  if (/\b(sick|ill|nausea|nauseous|hangover|hungover|vomit|headache|dizzy|pain|fever)\b/.test(text)) return "health"
  if (/\b(debug|bug|error|errors|exception|traceback|stack ?trace|broken|crash|failing|not working|doesn'?t work)\b/.test(text)) return "debug"
  if (/\b(plan|planning|roadmap|strategy|schedule|routine|timeline|organize|organise)\b/.test(text)) return "plan"
  if (/\b(advice|advise|guidance|help me decide|what should i do|how can i|should i)\b/.test(text)) return "advice"
  if (/\b(write|writing|rewrite|draft|wording|tone|email|message|caption)\b/.test(text)) return "write"
  if (/\b(learn|learning|study|understand|teach me|beginner)\b/.test(text)) return "learn"
  if (/\b(compare|comparison|versus|\bvs\.?\b)\b/.test(text)) return "compare"
  if (/\b(summary|summarize|recap|digest|tl;dr)\b/.test(text)) return "summary"
  if (/\b(brainstorm|brainstorming|ideas|idea generation)\b/.test(text)) return "brainstorm"
  if (/\b(analyze|analysis|evaluate|breakdown)\b/.test(text)) return "analyze"
  if (/\b(help|support|assist)\b/.test(text)) return "support"
  return null
}

function cleanupSubjectPhrase(value: string): string {
  let next = normalizeWhitespace(value)
  next = next.replace(/^(to|about|for|on|with)\s+/i, "")
  next = next.replace(/^(a|an|the)\s+/i, "")
  next = next.replace(/\b(please|thanks|thank you)$/i, "")
  next = next.replace(/[*_`#>~[\]]/g, "")
  next = next.replace(/\b(i feel|i am|i'm|im)\b/gi, "")
  next = next.replace(/\b(fun|interesting|cool|nice|good|great|awesome)\b$/i, "")
  next = next.replace(PUNCTUATION_TRIM_PATTERN, "")
  next = normalizeWhitespace(next)
  return next
}

function scoreSubjectCandidate(source: string, candidate: string): number {
  const sourceLower = source.toLowerCase()
  const candidateLower = candidate.toLowerCase()
  let score = 0
  if (new RegExp(`\\b${candidateLower.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\s+(?:is|are|was|were)\\b`, "i").test(sourceLower)) {
    score += 40
  }
  if (new RegExp(`\\b(?:about|regarding|on|for|with|into)\\s+${candidateLower.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`, "i").test(sourceLower)) {
    score += 30
  }
  if (new RegExp(`\\b(?:like|love|enjoy|hate|use|using|build|building|learn|learning|drank|drink|ate|eating)\\s+${candidateLower.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`, "i").test(sourceLower)) {
    score += 25
  }
  const candidateTokens = tokenize(candidateLower)
  if (candidateTokens.length === 1) score += 8
  if (candidateTokens.length >= 2 && candidateTokens.length <= 4) score += 12
  if (candidateTokens.some((token) => KNOWN_UPPER_WORDS.has(token))) score += 10
  if (candidateTokens.some((token) => token.length >= 7)) score += 6
  return score
}

function isLikelyValidSubject(value: string): boolean {
  const cleaned = cleanupSubjectPhrase(value)
  if (!cleaned) return false
  const tokens = tokenize(cleaned)
  if (tokens.length === 0) return false
  if (tokens.every((token) => TITLE_STOPWORDS.has(token) || SUBJECT_PRONOUNS.has(token))) return false
  if (tokens.length === 1 && INTENT_NOISE_WORDS.has(tokens[0])) return false
  return true
}

function extractSubjectCandidates(source: string): string[] {
  const cleaned = cleanSnippetText(source)
  if (!cleaned) return []

  const candidates = new Set<string>()
  const addCandidate = (value: string | null | undefined) => {
    const next = cleanupSubjectPhrase(String(value || ""))
    if (!next) return
    if (!isLikelyValidSubject(next)) return
    candidates.add(next)
  }

  const copulaPatterns = [
    /^\s*([A-Za-z0-9][A-Za-z0-9'./+-]*(?:\s+[A-Za-z0-9][A-Za-z0-9'./+-]*){0,4})\s+(?:is|are|was|were|seems?|feels?|sounds?)\b/i,
    /^\s*([A-Za-z0-9][A-Za-z0-9'./+-]*(?:\s+[A-Za-z0-9][A-Za-z0-9'./+-]*){0,4})\s+(?:can|could|should|would)\b/i,
  ]
  for (const pattern of copulaPatterns) {
    const match = pattern.exec(cleaned)
    if (match?.[1]) addCandidate(match[1])
  }

  const capturePatterns = [
    /\b(?:about|regarding|on|for|with|into)\s+([A-Za-z0-9][A-Za-z0-9'./+\-\s]{1,60})/gi,
    /\b(?:like|love|enjoy|hate|use|using|build|building|learn|learning|drank|drink|ate|eating)\s+([A-Za-z0-9][A-Za-z0-9'./+\-\s]{1,60})/gi,
    /\b(?:too much|way too much|a lot of|excess(?:ive|ively)?)\s+([A-Za-z0-9][A-Za-z0-9'./+\-\s]{1,60})/gi,
  ]
  for (const pattern of capturePatterns) {
    pattern.lastIndex = 0
    let match: RegExpExecArray | null
    while ((match = pattern.exec(cleaned)) !== null) {
      addCandidate(match[1])
    }
  }

  const tokenFallback = tokenize(cleaned).filter(
    (token) =>
      !TITLE_STOPWORDS.has(token) &&
      !INTENT_NOISE_WORDS.has(token) &&
      !SUBJECT_PRONOUNS.has(token) &&
      token.length >= 3,
  )
  if (tokenFallback.length > 0) {
    addCandidate(tokenFallback.slice(0, 4).join(" "))
    addCandidate(tokenFallback[0])
  }

  return [...candidates]
}

function selectBestSubject(source: string): string | null {
  const candidates = extractSubjectCandidates(source)
  if (candidates.length === 0) return null
  const ranked = candidates
    .map((candidate) => ({
      candidate,
      score: scoreSubjectCandidate(source, candidate),
    }))
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score
      if (a.candidate.length !== b.candidate.length) return a.candidate.length - b.candidate.length
      return a.candidate.localeCompare(b.candidate)
    })
  return ranked[0]?.candidate ?? null
}

function extractSubjectPhrase(source: string, intent: TitleIntent | null): string | null {
  const cleaned = cleanSnippetText(source)
  if (!cleaned) return null

  const lower = cleaned.toLowerCase()
  const patterns: Array<RegExp> = [
    /\b(?:cost|price|pricing|budget|spend(?:ing)?|afford|worth|value)\b(?:\s+(?:of|for|to|on))?\s+([^?.!]+)/i,
    /\b(?:debug|fix|solve|troubleshoot|issue with|problem with|error in|bug in)\s+([^?.!]+)/i,
    /\b(?:plan|roadmap|strategy|schedule|routine for|organize|organise)\s+([^?.!]+)/i,
    /\b(?:advice on|guidance on|help with)\s+([^?.!]+)/i,
    /\b(?:write|rewrite|draft|wording)\s+([^?.!]+)/i,
    /\b(?:learn|learning|study|understand)\s+([^?.!]+)/i,
    /\b(?:compare|comparison between|vs\.?)\s+([^?.!]+)/i,
    /\b(?:summary of|summarize|recap of|digest of)\s+([^?.!]+)/i,
  ]

  for (const pattern of patterns) {
    const match = pattern.exec(lower)
    if (!match?.[1]) continue
    const candidate = cleanupSubjectPhrase(match[1])
    if (candidate && !isLowSignalText(candidate)) {
      return candidate
    }
  }

  const tokens = tokenize(lower).filter(
    (token) => !TITLE_STOPWORDS.has(token) && !INTENT_NOISE_WORDS.has(token),
  )
  if (tokens.length === 0) return null

  let phrase = tokens.slice(0, 5).join(" ")
  if (intent === "cost") {
    const ofMatch = /\b(?:case|pack|bottle|set|bundle|subscription|plan|amount)\s+of\s+(.+)$/i.exec(cleaned)
    if (ofMatch?.[1]) {
      phrase = cleanupSubjectPhrase(ofMatch[1].toLowerCase()) || phrase
    }
  }
  const normalized = cleanupSubjectPhrase(phrase)
  if (normalized && isLikelyValidSubject(normalized)) return normalized
  return selectBestSubject(source)
}

function formatIntentTitle(intent: TitleIntent, rawSubject: string | null): string {
  const subject = rawSubject ? toTitleCaseWords(rawSubject) : null
  if (intent === "cost") return subject ? `${subject} Cost Breakdown` : "Cost Breakdown"
  if (intent === "health") return subject ? `${subject} Health Concern` : "Health Concern"
  if (intent === "debug") return subject ? `Fixing ${subject}` : "Troubleshooting"
  if (intent === "plan") return subject ? `${subject} Plan` : "Planning Session"
  if (intent === "advice") return subject ? `Advice on ${subject}` : "Advice & Guidance"
  if (intent === "write") return subject ? `Writing ${subject}` : "Writing Help"
  if (intent === "learn") return subject ? `Learning ${subject}` : "Learning Session"
  if (intent === "compare") return subject ? `${subject} Comparison` : "Comparison"
  if (intent === "summary") return subject ? `${subject} Summary` : "Quick Summary"
  if (intent === "brainstorm") return subject ? `${subject} Brainstorm` : "Brainstorming Session"
  if (intent === "analyze") return subject ? `${subject} Analysis` : "Analysis"
  return subject ? `${subject} Discussion` : "General Discussion"
}

function detectOverconsumptionTitle(userText: string): string | null {
  const baseline = normalizeWhitespace(userText).toLowerCase()
  if (!baseline) return null

  const hasHealthSignal = /\b(sick|ill|nausea|nauseous|hangover|hungover|vomit|headache|dizzy|unwell|badly)\b/.test(baseline)
  const hasConsumptionSignal = /\b(drank|drink|drinking|ate|eating|consumed|consuming|took|taking|using|used|had)\b/.test(baseline)
  if (!hasHealthSignal && !hasConsumptionSignal) return null

  const tooMuchMatch = /\b(?:too much|way too much|a lot of|excess(?:ive|ively)?)\s+([a-z0-9][a-z0-9'\s-]{1,40})\b/i.exec(baseline)
  if (!tooMuchMatch?.[1]) return null
  const subject = cleanupSubjectPhrase(tooMuchMatch[1]).replace(/\b(last night|yesterday|today|recently)\b/gi, "").trim()
  if (!subject || isLowSignalText(subject)) return null
  return `${toTitleCaseWords(subject)} Overconsumption`
}

function classifyTopicTitle(userText: string, assistantText: string): string | null {
  const baseline = normalizeWhitespace(userText).toLowerCase()
  if (!baseline) return null
  const overconsumptionTitle = detectOverconsumptionTitle(userText)
  if (overconsumptionTitle) return overconsumptionTitle
  const context = normalizeWhitespace(`${userText} ${assistantText}`).toLowerCase()
  const intent = detectIntent(baseline) || detectIntent(context)
  const subject = extractSubjectPhrase(userText, intent) || extractSubjectPhrase(context, intent) || selectBestSubject(userText)
  if (!intent) {
    if (!subject) return null
    return `${toTitleCaseWords(subject)} Talk`
  }
  return formatIntentTitle(intent, subject)
}

function createSnippetTitle(value: string): string | null {
  const cleaned = cleanSnippetText(value)
  if (!cleaned) return null
  const words = tokenize(cleaned)
  const focusedWords = words.filter((word) => !TITLE_STOPWORDS.has(word))
  if (focusedWords.length >= 2) {
    return toTitleCaseWords(focusedWords.slice(0, 5).join(" "))
  }
  const clipped = cleaned.length > 56 ? `${cleaned.slice(0, 56).trimEnd()}...` : cleaned
  if (!clipped) return null
  return clipped.charAt(0).toUpperCase() + clipped.slice(1)
}

function formatGenericConversationTitle(now?: Date): string {
  const date = now ?? new Date()
  const timeLabel = date.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })
  return `${GENERIC_CONVERSATION_TITLE_PREFIX} - ${timeLabel}`
}

function deriveConversationTitle(
  messages: ChatMessage[],
  now?: Date,
): { title: string; kind: DerivedTitleKind } {
  const userMessages = messages
    .filter((message) => message.role === "user")
    .map((message) => normalizeWhitespace(String(message.content || "")))
    .filter(Boolean)
  const meaningfulUserMessages = userMessages.filter((entry) => !isLowSignalText(entry))
  const firstMeaningfulUserMessage = meaningfulUserMessages[0] || ""
  const userContext = meaningfulUserMessages.slice(0, 3).join(" ")
  const assistantHint = normalizeWhitespace(
    String(messages.find((message) => message.role === "assistant" && message.content.trim())?.content || ""),
  ).slice(0, 240)

  if (firstMeaningfulUserMessage) {
    const topicTitle = classifyTopicTitle(firstMeaningfulUserMessage, assistantHint)
    if (topicTitle) return { title: topicTitle, kind: "topic" }
    const snippetTitle = createSnippetTitle(firstMeaningfulUserMessage)
    if (snippetTitle) return { title: snippetTitle, kind: "snippet" }
  }

  if (userContext && userContext !== firstMeaningfulUserMessage) {
    const contextTopicTitle = classifyTopicTitle(userContext, assistantHint)
    if (contextTopicTitle) return { title: contextTopicTitle, kind: "topic" }
    const contextSnippetTitle = createSnippetTitle(userContext)
    if (contextSnippetTitle) return { title: contextSnippetTitle, kind: "snippet" }
  }

  if (assistantHint) {
    const topicFromAssistant = classifyTopicTitle("", assistantHint)
    if (topicFromAssistant) return { title: topicFromAssistant, kind: "topic" }
  }

  return { title: formatGenericConversationTitle(now), kind: "generic" }
}

export function isAutoGeneratedConversationTitle(title: string | null | undefined): boolean {
  const normalized = normalizeWhitespace(String(title || ""))
  if (!normalized) return true
  if (DEFAULT_CONVERSATION_TITLE_PATTERN.test(normalized)) return true
  if (GENERIC_CONVERSATION_TITLE_PATTERN.test(normalized)) return true
  if (LEGACY_GENERIC_CONVERSATION_TITLE_PATTERN.test(normalized)) return true
  if (isLowSignalText(normalized)) return true
  return false
}

function ensureUniqueConversationTitle(
  baseTitle: string,
  conversations: Conversation[],
  conversationId?: string,
): string {
  const trimmedBase = normalizeWhitespace(baseTitle) || DEFAULT_CONVERSATION_TITLE
  const usedTitles = new Set(
    conversations
      .filter((conversation) => conversation.id !== conversationId)
      .map((conversation) => normalizeForComparison(conversation.title)),
  )
  if (!usedTitles.has(normalizeForComparison(trimmedBase))) return trimmedBase

  const stem = trimmedBase.replace(/\s+\(\d+\)$/u, "")
  let suffix = 2
  while (suffix < 1000) {
    const candidate = `${stem} (${suffix})`
    if (!usedTitles.has(normalizeForComparison(candidate))) {
      return candidate
    }
    suffix += 1
  }
  return `${stem} (${Date.now()})`
}

export function resolveConversationTitle(params: {
  messages: ChatMessage[]
  currentTitle?: string | null
  conversations?: Conversation[]
  conversationId?: string
  now?: Date
}): string {
  const currentTitle = normalizeWhitespace(String(params.currentTitle || ""))
  const canAutoRetitle = isAutoGeneratedConversationTitle(currentTitle)
  if (!canAutoRetitle && currentTitle) return currentTitle

  const { title, kind } = deriveConversationTitle(params.messages, params.now)
  const generated = normalizeWhitespace(title) || DEFAULT_CONVERSATION_TITLE
  const baseTitle = kind === "generic" ? generated : capAutoGeneratedTitleWords(generated, MAX_AUTO_TITLE_WORDS)
  const existing = Array.isArray(params.conversations) ? params.conversations : []
  return ensureUniqueConversationTitle(baseTitle, existing, params.conversationId)
}

const CONVERSATIONS_KEY_PREFIX = "nova-conversations"
const ACTIVE_KEY_PREFIX = "nova-active-conversation"
const LEGACY_CONVERSATIONS_KEY = "nova-conversations"
const LEGACY_ACTIVE_KEY = "nova-active-conversation"

function getConversationsKey(): string {
  const userId = getActiveUserId()
  return userId ? `${CONVERSATIONS_KEY_PREFIX}:${userId}` : ""
}

function getActiveKey(): string {
  const userId = getActiveUserId()
  return userId ? `${ACTIVE_KEY_PREFIX}:${userId}` : ""
}

function migrateLegacyConversationsIfNeeded(): void {
  const scopedConversationsKey = getConversationsKey()
  if (!scopedConversationsKey) return
  if (!localStorage.getItem(scopedConversationsKey)) {
    const legacy = localStorage.getItem(LEGACY_CONVERSATIONS_KEY)
    if (legacy) {
      localStorage.setItem(scopedConversationsKey, legacy)
      localStorage.removeItem(LEGACY_CONVERSATIONS_KEY)
    }
  }
  const scopedActiveKey = getActiveKey()
  if (!scopedActiveKey) return
  if (!localStorage.getItem(scopedActiveKey)) {
    const legacyActive = localStorage.getItem(LEGACY_ACTIVE_KEY)
    if (legacyActive) {
      localStorage.setItem(scopedActiveKey, legacyActive)
      localStorage.removeItem(LEGACY_ACTIVE_KEY)
    }
  }
}

export function generateId(): string {
  return `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
}

export function loadConversations(): Conversation[] {
  try {
    const key = getConversationsKey()
    if (!key) return []
    migrateLegacyConversationsIfNeeded()
    const raw = localStorage.getItem(key)
    return raw ? JSON.parse(raw) : []
  } catch {
    return []
  }
}

export function saveConversations(convos: Conversation[]) {
  const key = getConversationsKey()
  if (!key) return
  localStorage.setItem(key, JSON.stringify(convos))
}

export function getActiveId(): string | null {
  const key = getActiveKey()
  if (!key) return null
  migrateLegacyConversationsIfNeeded()
  return localStorage.getItem(key)
}

export function setActiveId(id: string | null) {
  const key = getActiveKey()
  if (!key) return
  if (id) localStorage.setItem(key, id)
  else localStorage.removeItem(key)
}

export function createConversation(): Conversation {
  const now = new Date().toISOString()
  return {
    id: generateId(),
    title: DEFAULT_CONVERSATION_TITLE,
    messages: [],
    createdAt: now,
    updatedAt: now,
  }
}

export function autoTitle(messages: ChatMessage[]): string {
  const { title, kind } = deriveConversationTitle(messages)
  const generated = normalizeWhitespace(title) || DEFAULT_CONVERSATION_TITLE
  return kind === "generic" ? generated : capAutoGeneratedTitleWords(generated, MAX_AUTO_TITLE_WORDS)
}

import type { Conversation, ChatMessage } from "@/lib/chat/conversations"
import { isAutoGeneratedConversationTitle } from "@/lib/chat/conversations"

export function parseIsoTimestamp(value: string | undefined): number {
  const ts = Date.parse(String(value || ""))
  return Number.isFinite(ts) ? ts : 0
}

export function normalizeMessageComparableText(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
}

export function normalizeMessageComparableCompact(value: string): string {
  return normalizeMessageComparableText(value).replace(/[^a-z0-9]+/g, "")
}

function areLikelySameMessage(local: ChatMessage, server: ChatMessage): boolean {
  if (!local || !server) return false
  if (local.role !== server.role) return false
  const localText = normalizeMessageComparableText(local.content)
  const serverText = normalizeMessageComparableText(server.content)
  if (!localText || !serverText) return false
  if (localText === serverText) return true
  const localCompact = normalizeMessageComparableCompact(local.content)
  const serverCompact = normalizeMessageComparableCompact(server.content)
  if (!localCompact || !serverCompact) return false
  if (localCompact === serverCompact) return true
  if (localCompact.includes(serverCompact) || serverCompact.includes(localCompact)) {
    const smaller = Math.min(localCompact.length, serverCompact.length)
    const larger = Math.max(localCompact.length, serverCompact.length)
    return smaller / Math.max(1, larger) >= 0.72
  }
  return false
}

function stabilizeServerMessageIds(localMessages: ChatMessage[], serverMessages: ChatMessage[]): ChatMessage[] {
  if (!Array.isArray(localMessages) || !Array.isArray(serverMessages)) return serverMessages
  if (localMessages.length === 0 || serverMessages.length === 0) return serverMessages

  const usedLocalIndexes = new Set<number>()
  const usedOutputIds = new Set<string>()
  const localIndexById = new Map<string, number>()
  for (let i = 0; i < localMessages.length; i += 1) {
    const localId = String(localMessages[i]?.id || "").trim()
    if (localId && !localIndexById.has(localId)) localIndexById.set(localId, i)
  }

  const claimLocalIndex = (index: number): ChatMessage | null => {
    if (index < 0 || index >= localMessages.length) return null
    if (usedLocalIndexes.has(index)) return null
    usedLocalIndexes.add(index)
    return localMessages[index]
  }

  const pickMatchingLocal = (serverMessage: ChatMessage, serverIndex: number): ChatMessage | null => {
    const serverId = String(serverMessage?.id || "").trim()
    if (serverId) {
      const exact = localIndexById.get(serverId)
      if (typeof exact === "number") {
        const claimed = claimLocalIndex(exact)
        if (claimed) return claimed
      }
    }

    const sameIndex = claimLocalIndex(serverIndex)
    if (sameIndex && areLikelySameMessage(sameIndex, serverMessage)) return sameIndex
    if (sameIndex && !areLikelySameMessage(sameIndex, serverMessage)) {
      usedLocalIndexes.delete(serverIndex)
    }

    const windowStart = Math.max(0, serverIndex - 2)
    const windowEnd = Math.min(localMessages.length - 1, serverIndex + 2)
    for (let i = windowStart; i <= windowEnd; i += 1) {
      if (usedLocalIndexes.has(i)) continue
      if (!areLikelySameMessage(localMessages[i], serverMessage)) continue
      const claimed = claimLocalIndex(i)
      if (claimed) return claimed
    }

    for (let i = 0; i < localMessages.length; i += 1) {
      if (usedLocalIndexes.has(i)) continue
      if (!areLikelySameMessage(localMessages[i], serverMessage)) continue
      const claimed = claimLocalIndex(i)
      if (claimed) return claimed
    }

    return null
  }

  return serverMessages.map((serverMessage, serverIndex) => {
    const matchedLocal = pickMatchingLocal(serverMessage, serverIndex)
    const candidateId = String(matchedLocal?.id || serverMessage.id || "").trim()
    if (!candidateId || usedOutputIds.has(candidateId)) {
      const fallbackId = String(serverMessage.id || "").trim()
      if (fallbackId) usedOutputIds.add(fallbackId)
      return { ...serverMessage, id: fallbackId || candidateId || `msg-${serverIndex}` }
    }
    usedOutputIds.add(candidateId)
    return { ...serverMessage, id: candidateId }
  })
}

export const USER_ECHO_DEDUP_MS = 15_000
export const ASSISTANT_ECHO_DEDUP_MS = 60_000
export const OPTIMISTIC_ID_REGEX = /^\d+-[a-z0-9]+$/
export const MISSION_SPAM_COOLDOWN_MS = 30_000
export const MISSION_INFLIGHT_MAX_MS = 90_000

export function normalizeMissionPromptSignature(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 260)
}

export function isLikelyMissionPrompt(value: string): boolean {
  const text = normalizeMissionPromptSignature(value)
  if (!text) return false
  return /\b(mission|workflow|automation|schedule|scheduled|remind|reminder|every day|daily|weekday)\b/.test(text)
}

export function buildMissionScopeKey(userContextId: string, sessionConversationId: string): string {
  const user = String(userContextId || "").trim().toLowerCase() || "anonymous"
  const convo = String(sessionConversationId || "").trim().toLowerCase() || "none"
  return `mission:${user}:${convo}`
}

function normalizeMessageSignature(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 220)
}

function firstUserMessageSignature(convo: Conversation): string {
  const firstUser = convo.messages.find((m) => m.role === "user" && String(m.content || "").trim().length > 0)
  return normalizeMessageSignature(String(firstUser?.content || ""))
}

function normalizeTitleSignature(value: string): string {
  return String(value || "").toLowerCase().replace(/\s+/g, " ").trim()
}

export function isLikelyOptimisticDuplicate(localConvo: Conversation, remoteConvo: Conversation): boolean {
  if (!OPTIMISTIC_ID_REGEX.test(localConvo.id) || OPTIMISTIC_ID_REGEX.test(remoteConvo.id)) return false

  const localUserSig = firstUserMessageSignature(localConvo)
  const remoteUserSig = firstUserMessageSignature(remoteConvo)
  if (localUserSig || remoteUserSig) {
    if (!(localUserSig && remoteUserSig)) return false
    if (localUserSig === remoteUserSig) return true
    const localContainsRemote = localUserSig.length > 18 && localUserSig.startsWith(remoteUserSig)
    const remoteContainsLocal = remoteUserSig.length > 18 && remoteUserSig.startsWith(localUserSig)
    return localContainsRemote || remoteContainsLocal
  }

  const localTitle = normalizeTitleSignature(localConvo.title)
  const remoteTitle = normalizeTitleSignature(remoteConvo.title)
  if (!localTitle || !remoteTitle || localTitle !== remoteTitle) return false

  const localUpdated = parseIsoTimestamp(localConvo.updatedAt)
  const remoteUpdated = parseIsoTimestamp(remoteConvo.updatedAt)
  return Math.abs(localUpdated - remoteUpdated) <= 3 * 60 * 1000
}

export type IncomingAgentMessage = {
  id: string
  role: "user" | "assistant"
  content: string
  ts: number
  source?: string
  sender?: string
  conversationId?: string
  nlpCleanText?: string
  nlpConfidence?: number
  nlpCorrectionCount?: number
  nlpBypass?: boolean
}

function normalizeChatSource(value: unknown): "hud" | "agent" | "voice" | undefined {
  const source = String(value || "").trim().toLowerCase()
  if (source === "hud" || source === "agent" || source === "voice") return source
  return undefined
}

export type PendingMissionMessage = {
  id: string
  title: string
  content: string
  missionId?: string
  missionLabel?: string
  metadata?: {
    missionRunId?: string
    runKey?: string
    attempt?: number
    source?: "scheduler" | "trigger"
    outputChannel?: string
    deliveryKey?: string
  }
  createdAt: string
}

export function resolvePendingMissionGroupKey(msg: PendingMissionMessage): string {
  const deliveryKey = String(msg.metadata?.deliveryKey || "").trim()
  if (deliveryKey) {
    const deliveryParts = deliveryKey.split(":")
    if (deliveryParts.length >= 2) {
      return `run:${deliveryParts[0]}:${deliveryParts[1]}`
    }
  }
  const missionId = String(msg.missionId || "").trim() || "mission"
  const missionRunId = String(msg.metadata?.missionRunId || "").trim()
  const runKey = String(msg.metadata?.runKey || "").trim()
  if (missionRunId) return `run:${missionId}:${missionRunId}`
  if (runKey) return `run:${missionId}:${runKey}`
  return `message:${msg.id}`
}

export function resolvePendingMissionDeliveryKey(msg: PendingMissionMessage): string {
  const explicit = String(msg.metadata?.deliveryKey || "").trim()
  if (explicit) return explicit
  const missionId = String(msg.missionId || "").trim() || "mission"
  const missionRunId = String(msg.metadata?.missionRunId || "").trim()
  const runKey = String(msg.metadata?.runKey || "").trim()
  const contentSig = normalizeMessageComparableCompact(String(msg.content || "")).slice(0, 80) || "content"
  return `fallback:${missionId}:${missionRunId || runKey || "run"}:${contentSig}`
}

export function mergeConversationsPreferLocal(
  local: Conversation[],
  remote: Conversation[],
  optimisticIdToServerId: Map<string, string> = new Map<string, string>(),
): Conversation[] {
  if (local.length === 0) return remote
  if (remote.length === 0) return local

  const localById = new Map(local.map((entry) => [entry.id, entry]))
  const mappedLocalByServerId = new Map<string, Conversation>()
  for (const localConvo of local) {
    const mappedServerId = optimisticIdToServerId.get(localConvo.id)
    if (!mappedServerId) continue
    if (localById.has(mappedServerId)) continue
    if (!mappedLocalByServerId.has(mappedServerId)) {
      mappedLocalByServerId.set(mappedServerId, localConvo)
    }
  }
  const merged = remote.map((serverConvo) => {
    const localConvo = localById.get(serverConvo.id) || mappedLocalByServerId.get(serverConvo.id)
    if (!localConvo) return serverConvo

    const localUpdated = parseIsoTimestamp(localConvo.updatedAt)
    const serverUpdated = parseIsoTimestamp(serverConvo.updatedAt)
    const localLooksNewer =
      localConvo.messages.length > serverConvo.messages.length || localUpdated > serverUpdated
    if (!localLooksNewer) {
      return {
        ...serverConvo,
        messages: stabilizeServerMessageIds(localConvo.messages, serverConvo.messages),
      }
    }

    return {
      ...serverConvo,
      title:
        localConvo.title && !isAutoGeneratedConversationTitle(localConvo.title) ? localConvo.title : serverConvo.title,
      messages: localConvo.messages,
      updatedAt: localUpdated >= serverUpdated ? localConvo.updatedAt : serverConvo.updatedAt,
      pinned: localConvo.pinned ?? serverConvo.pinned,
      archived: localConvo.archived ?? serverConvo.archived,
    }
  })

  const remoteIds = new Set(remote.map((entry) => entry.id))
  const localOnly = local.filter((entry) => {
    if (remoteIds.has(entry.id)) return false
    const mappedServerId = optimisticIdToServerId.get(entry.id)
    if (mappedServerId && remoteIds.has(mappedServerId)) return false
    if (!OPTIMISTIC_ID_REGEX.test(entry.id)) return true
    for (const remoteEntry of remote) {
      if (isLikelyOptimisticDuplicate(entry, remoteEntry)) return false
    }
    return true
  })
  return [...merged, ...localOnly].sort(
    (a, b) => parseIsoTimestamp(b.updatedAt) - parseIsoTimestamp(a.updatedAt),
  )
}

export function mergeIncomingAgentMessages(
  existingMessages: ChatMessage[],
  incomingMessages: IncomingAgentMessage[],
): ChatMessage[] {
  const coerceIncomingTimestampMs = (value: unknown): number => {
    const parsed = Number(value)
    return Number.isFinite(parsed) && parsed > 0 ? Math.floor(parsed) : Date.now()
  }

  const shouldPreferIncomingAssistantVersion = (base: string, incoming: string): boolean => {
    const left = normalizeMessageComparableText(base)
    const right = normalizeMessageComparableText(incoming)
    if (!left || !right) return false
    if (left === right) return true

    const leftCompact = left.replace(/[^a-z0-9]+/g, "")
    const rightCompact = right.replace(/[^a-z0-9]+/g, "")
    if (!leftCompact || !rightCompact) return false
    if (rightCompact.includes(leftCompact)) return true
    if (leftCompact.includes(rightCompact)) return false

    const leftWords = new Set(left.split(/\s+/g).filter(Boolean))
    const rightWords = new Set(right.split(/\s+/g).filter(Boolean))
    if (leftWords.size < 8 || rightWords.size < 8) return false
    let overlap = 0
    for (const word of leftWords) {
      if (rightWords.has(word)) overlap += 1
    }
    const smaller = Math.min(leftWords.size, rightWords.size)
    const overlapRatio = smaller > 0 ? overlap / smaller : 0
    const lenRatio = Math.min(leftCompact.length, rightCompact.length) / Math.max(leftCompact.length, rightCompact.length)
    return overlapRatio >= 0.82 && lenRatio >= 0.62
  }

  const mergeAssistantContent = (base: string, incoming: string): string => {
    const left = String(base || "")
    const right = String(incoming || "")
    if (!right) return left
    if (!left) return right
    if (shouldPreferIncomingAssistantVersion(left, right)) {
      return right.length >= left.length ? right : left
    }
    if (right.length >= left.length && right.startsWith(left)) return right
    if (left.length >= right.length && left.startsWith(right)) return left
    if (left.endsWith(right)) return left
    if (right.endsWith(left)) return right
    return `${left}${right}`
  }

  const dedupedExisting: ChatMessage[] = []
  for (const existing of existingMessages) {
    if (existing.role !== "assistant") {
      dedupedExisting.push(existing)
      continue
    }
    const existingText = normalizeMessageComparableText(existing.content)
    if (!existingText) {
      dedupedExisting.push(existing)
      continue
    }
    const duplicateIdx = dedupedExisting.findIndex((candidate) => {
      if (candidate.role !== "assistant") return false
      if (Math.abs(parseIsoTimestamp(candidate.createdAt) - parseIsoTimestamp(existing.createdAt)) > ASSISTANT_ECHO_DEDUP_MS) {
        return false
      }
      return normalizeMessageComparableText(candidate.content) === existingText
    })
    if (duplicateIdx === -1) {
      dedupedExisting.push(existing)
      continue
    }
    const current = dedupedExisting[duplicateIdx]
    if (shouldPreferIncomingAssistantVersion(current.content, existing.content)) {
      dedupedExisting[duplicateIdx] = {
        ...current,
        content: mergeAssistantContent(current.content, existing.content),
        createdAt: parseIsoTimestamp(current.createdAt) >= parseIsoTimestamp(existing.createdAt) ? current.createdAt : existing.createdAt,
        sender: existing.sender || current.sender,
      }
    }
  }

  const out = [...dedupedExisting]
  const incomingAssistantByText = new Map<string, number>()
  for (let i = 0; i < out.length; i += 1) {
    const msg = out[i]
    if (msg.role !== "assistant") continue
    const key = normalizeMessageComparableText(msg.content)
    if (!key) continue
    if (!incomingAssistantByText.has(key)) incomingAssistantByText.set(key, i)
  }
  for (const incoming of incomingMessages) {
    const incomingTs = coerceIncomingTimestampMs(incoming.ts)
    if (incoming.role === "assistant") {
      const incomingNorm = normalizeMessageComparableText(incoming.content)
      const matchIdx = incomingNorm ? incomingAssistantByText.get(incomingNorm) : undefined
      if (typeof matchIdx === "number") {
        const base = out[matchIdx]
        out[matchIdx] = {
          ...base,
          content: mergeAssistantContent(base.content, incoming.content),
          sender: incoming.sender || base.sender,
          source: normalizeChatSource(incoming.source) || base.source,
          createdAt: parseIsoTimestamp(base.createdAt) >= incomingTs ? base.createdAt : new Date(incomingTs).toISOString(),
        }
        continue
      }
    }
    out.push({
      id: incoming.id,
      role: incoming.role,
      content: incoming.content,
      createdAt: new Date(incomingTs).toISOString(),
      source: normalizeChatSource(incoming.source) || "agent",
      sender: incoming.sender,
      nlpCleanText: incoming.nlpCleanText,
      nlpConfidence: incoming.nlpConfidence,
      nlpCorrectionCount: incoming.nlpCorrectionCount,
      nlpBypass: incoming.nlpBypass,
    })
  }
  return out
}

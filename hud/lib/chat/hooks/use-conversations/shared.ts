import type { Conversation, ChatMessage } from "@/lib/chat/conversations"
import { isAutoGeneratedConversationTitle } from "@/lib/chat/conversations"

export function parseIsoTimestamp(value: string | undefined): number {
  const ts = Date.parse(String(value || ""))
  return Number.isFinite(ts) ? ts : 0
}

export function normalizeMessageComparableText(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
}

export function normalizeMessageComparableCompact(value: string): string {
  return normalizeMessageComparableText(value).replace(/[^a-z0-9]+/g, "")
}

function areLikelySameMessage(local: ChatMessage, server: ChatMessage): boolean {
  if (!local || !server) return false
  if (local.role !== server.role) return false
  const localText = normalizeMessageComparableText(local.content)
  const serverText = normalizeMessageComparableText(server.content)
  if (!localText || !serverText) return false
  if (localText === serverText) return true
  const localCompact = normalizeMessageComparableCompact(local.content)
  const serverCompact = normalizeMessageComparableCompact(server.content)
  if (!localCompact || !serverCompact) return false
  if (localCompact === serverCompact) return true
  if (localCompact.includes(serverCompact) || serverCompact.includes(localCompact)) {
    const smaller = Math.min(localCompact.length, serverCompact.length)
    const larger = Math.max(localCompact.length, serverCompact.length)
    return smaller / Math.max(1, larger) >= 0.72
  }
  return false
}

function stabilizeServerMessageIds(localMessages: ChatMessage[], serverMessages: ChatMessage[]): ChatMessage[] {
  if (!Array.isArray(localMessages) || !Array.isArray(serverMessages)) return serverMessages
  if (localMessages.length === 0 || serverMessages.length === 0) return serverMessages

  const usedLocalIndexes = new Set<number>()
  const usedOutputIds = new Set<string>()
  const localIndexById = new Map<string, number>()
  for (let i = 0; i < localMessages.length; i += 1) {
    const localId = String(localMessages[i]?.id || "").trim()
    if (localId && !localIndexById.has(localId)) localIndexById.set(localId, i)
  }

  const claimLocalIndex = (index: number): ChatMessage | null => {
    if (index < 0 || index >= localMessages.length) return null
    if (usedLocalIndexes.has(index)) return null
    usedLocalIndexes.add(index)
    return localMessages[index]
  }

  const pickMatchingLocal = (serverMessage: ChatMessage, serverIndex: number): ChatMessage | null => {
    const serverId = String(serverMessage?.id || "").trim()
    if (serverId) {
      const exact = localIndexById.get(serverId)
      if (typeof exact === "number") {
        const claimed = claimLocalIndex(exact)
        if (claimed) return claimed
      }
    }

    const sameIndex = claimLocalIndex(serverIndex)
    if (sameIndex && areLikelySameMessage(sameIndex, serverMessage)) return sameIndex
    if (sameIndex && !areLikelySameMessage(sameIndex, serverMessage)) {
      usedLocalIndexes.delete(serverIndex)
    }

    const windowStart = Math.max(0, serverIndex - 2)
    const windowEnd = Math.min(localMessages.length - 1, serverIndex + 2)
    for (let i = windowStart; i <= windowEnd; i += 1) {
      if (usedLocalIndexes.has(i)) continue
      if (!areLikelySameMessage(localMessages[i], serverMessage)) continue
      const claimed = claimLocalIndex(i)
      if (claimed) return claimed
    }

    for (let i = 0; i < localMessages.length; i += 1) {
      if (usedLocalIndexes.has(i)) continue
      if (!areLikelySameMessage(localMessages[i], serverMessage)) continue
      const claimed = claimLocalIndex(i)
      if (claimed) return claimed
    }

    return null
  }

  return serverMessages.map((serverMessage, serverIndex) => {
    const matchedLocal = pickMatchingLocal(serverMessage, serverIndex)
    const candidateId = String(matchedLocal?.id || serverMessage.id || "").trim()
    if (!candidateId || usedOutputIds.has(candidateId)) {
      const fallbackId = String(serverMessage.id || "").trim()
      if (fallbackId) usedOutputIds.add(fallbackId)
      return { ...serverMessage, id: fallbackId || candidateId || `msg-${serverIndex}` }
    }
    usedOutputIds.add(candidateId)
    return { ...serverMessage, id: candidateId }
  })
}

export const OPTIMISTIC_ID_REGEX = /^\d+-[a-z0-9]+$/
export const MISSION_SPAM_COOLDOWN_MS = 30_000
export const MISSION_INFLIGHT_MAX_MS = 90_000

export function normalizeMissionPromptSignature(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 260)
}

export function isLikelyMissionPrompt(value: string): boolean {
  const text = normalizeMissionPromptSignature(value)
  if (!text) return false
  return /\b(mission|workflow|automation|schedule|scheduled|remind|reminder|every day|daily|weekday)\b/.test(text)
}

export function buildMissionScopeKey(userContextId: string, sessionConversationId: string): string {
  const user = String(userContextId || "").trim().toLowerCase() || "anonymous"
  const convo = String(sessionConversationId || "").trim().toLowerCase() || "none"
  return `mission:${user}:${convo}`
}

function normalizeMessageSignature(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 220)
}

function firstUserMessageSignature(convo: Conversation): string {
  const firstUser = convo.messages.find((m) => m.role === "user" && String(m.content || "").trim().length > 0)
  return normalizeMessageSignature(String(firstUser?.content || ""))
}

function normalizeTitleSignature(value: string): string {
  return String(value || "").toLowerCase().replace(/\s+/g, " ").trim()
}

export function isLikelyOptimisticDuplicate(localConvo: Conversation, remoteConvo: Conversation): boolean {
  if (!OPTIMISTIC_ID_REGEX.test(localConvo.id) || OPTIMISTIC_ID_REGEX.test(remoteConvo.id)) return false

  const localUserSig = firstUserMessageSignature(localConvo)
  const remoteUserSig = firstUserMessageSignature(remoteConvo)
  if (localUserSig || remoteUserSig) {
    if (!(localUserSig && remoteUserSig)) return false
    if (localUserSig === remoteUserSig) return true
    const localContainsRemote = localUserSig.length > 18 && localUserSig.startsWith(remoteUserSig)
    const remoteContainsLocal = remoteUserSig.length > 18 && remoteUserSig.startsWith(localUserSig)
    return localContainsRemote || remoteContainsLocal
  }

  const localTitle = normalizeTitleSignature(localConvo.title)
  const remoteTitle = normalizeTitleSignature(remoteConvo.title)
  if (!localTitle || !remoteTitle || localTitle !== remoteTitle) return false

  const localUpdated = parseIsoTimestamp(localConvo.updatedAt)
  const remoteUpdated = parseIsoTimestamp(remoteConvo.updatedAt)
  return Math.abs(localUpdated - remoteUpdated) <= 3 * 60 * 1000
}

export type PendingMissionMessage = {
  id: string
  title: string
  content: string
  missionId?: string
  missionLabel?: string
  metadata?: {
    missionRunId?: string
    runKey?: string
    attempt?: number
    source?: "scheduler" | "trigger"
    outputChannel?: string
    deliveryKey?: string
  }
  createdAt: string
}

export function resolvePendingMissionGroupKey(msg: PendingMissionMessage): string {
  const deliveryKey = String(msg.metadata?.deliveryKey || "").trim()
  if (deliveryKey) {
    const deliveryParts = deliveryKey.split(":")
    if (deliveryParts.length >= 2) {
      return `run:${deliveryParts[0]}:${deliveryParts[1]}`
    }
  }
  const missionId = String(msg.missionId || "").trim() || "mission"
  const missionRunId = String(msg.metadata?.missionRunId || "").trim()
  const runKey = String(msg.metadata?.runKey || "").trim()
  if (missionRunId) return `run:${missionId}:${missionRunId}`
  if (runKey) return `run:${missionId}:${runKey}`
  return `message:${msg.id}`
}

export function resolvePendingMissionDeliveryKey(msg: PendingMissionMessage): string {
  const explicit = String(msg.metadata?.deliveryKey || "").trim()
  if (explicit) return explicit
  const missionId = String(msg.missionId || "").trim() || "mission"
  const missionRunId = String(msg.metadata?.missionRunId || "").trim()
  const runKey = String(msg.metadata?.runKey || "").trim()
  const contentSig = normalizeMessageComparableCompact(String(msg.content || "")).slice(0, 80) || "content"
  return `fallback:${missionId}:${missionRunId || runKey || "run"}:${contentSig}`
}

export function mergeConversationsPreferLocal(
  local: Conversation[],
  remote: Conversation[],
  optimisticIdToServerId: Map<string, string> = new Map<string, string>(),
): Conversation[] {
  if (local.length === 0) return remote
  if (remote.length === 0) return local

  const localById = new Map(local.map((entry) => [entry.id, entry]))
  const mappedLocalByServerId = new Map<string, Conversation>()
  for (const localConvo of local) {
    const mappedServerId = optimisticIdToServerId.get(localConvo.id)
    if (!mappedServerId) continue
    if (localById.has(mappedServerId)) continue
    if (!mappedLocalByServerId.has(mappedServerId)) {
      mappedLocalByServerId.set(mappedServerId, localConvo)
    }
  }
  const merged = remote.map((serverConvo) => {
    const localConvo = localById.get(serverConvo.id) || mappedLocalByServerId.get(serverConvo.id)
    if (!localConvo) return serverConvo

    const localUpdated = parseIsoTimestamp(localConvo.updatedAt)
    const serverUpdated = parseIsoTimestamp(serverConvo.updatedAt)
    const localLooksNewer =
      localConvo.messages.length > serverConvo.messages.length || localUpdated > serverUpdated
    if (!localLooksNewer) {
      return {
        ...serverConvo,
        messages: stabilizeServerMessageIds(localConvo.messages, serverConvo.messages),
      }
    }

    return {
      ...serverConvo,
      title:
        localConvo.title && !isAutoGeneratedConversationTitle(localConvo.title) ? localConvo.title : serverConvo.title,
      messages: localConvo.messages,
      updatedAt: localUpdated >= serverUpdated ? localConvo.updatedAt : serverConvo.updatedAt,
      pinned: localConvo.pinned ?? serverConvo.pinned,
      archived: localConvo.archived ?? serverConvo.archived,
    }
  })

  const remoteIds = new Set(remote.map((entry) => entry.id))
  const localOnly = local.filter((entry) => {
    if (remoteIds.has(entry.id)) return false
    const mappedServerId = optimisticIdToServerId.get(entry.id)
    if (mappedServerId && remoteIds.has(mappedServerId)) return false
    if (!OPTIMISTIC_ID_REGEX.test(entry.id)) return true
    for (const remoteEntry of remote) {
      if (isLikelyOptimisticDuplicate(entry, remoteEntry)) return false
    }
    return true
  })
  return [...merged, ...localOnly].sort(
    (a, b) => parseIsoTimestamp(b.updatedAt) - parseIsoTimestamp(a.updatedAt),
  )
}

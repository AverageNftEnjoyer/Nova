"use client"

import { useState, useEffect, useLayoutEffect, useCallback, useRef } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import {
  type Conversation,
  type ChatMessage,
  generateId,
  getActiveId,
  isAutoGeneratedConversationTitle,
  loadConversations,
  saveConversations,
  setActiveId,
  DEFAULT_CONVERSATION_TITLE,
  resolveConversationTitle,
} from "@/lib/chat/conversations"
import { readShellUiCache, writeShellUiCache } from "@/lib/settings/shell-ui-cache"

function parseIsoTimestamp(value: string | undefined): number {
  const ts = Date.parse(String(value || ""))
  return Number.isFinite(ts) ? ts : 0
}

const USER_ECHO_DEDUP_MS = 15_000

type IncomingAgentMessage = {
  id: string
  role: "user" | "assistant"
  content: string
  ts: number
  source?: string
  sender?: string
  conversationId?: string
  nlpCleanText?: string
  nlpConfidence?: number
  nlpCorrectionCount?: number
  nlpBypass?: boolean
}

function mergeConversationsPreferLocal(
  local: Conversation[],
  remote: Conversation[],
): Conversation[] {
  if (local.length === 0) return remote
  if (remote.length === 0) return local

  const localById = new Map(local.map((entry) => [entry.id, entry]))
  const merged = remote.map((serverConvo) => {
    const localConvo = localById.get(serverConvo.id)
    if (!localConvo) return serverConvo

    const localUpdated = parseIsoTimestamp(localConvo.updatedAt)
    const serverUpdated = parseIsoTimestamp(serverConvo.updatedAt)
    const localLooksNewer =
      localConvo.messages.length > serverConvo.messages.length || localUpdated > serverUpdated
    if (!localLooksNewer) return serverConvo

    return {
      ...serverConvo,
      title:
        localConvo.title && !isAutoGeneratedConversationTitle(localConvo.title) ? localConvo.title : serverConvo.title,
      messages: localConvo.messages,
      updatedAt: localUpdated >= serverUpdated ? localConvo.updatedAt : serverConvo.updatedAt,
      pinned: localConvo.pinned ?? serverConvo.pinned,
      archived: localConvo.archived ?? serverConvo.archived,
    }
  })

  const remoteIds = new Set(remote.map((entry) => entry.id))
  const localOnly = local.filter((entry) => !remoteIds.has(entry.id))
  return [...merged, ...localOnly].sort(
    (a, b) => parseIsoTimestamp(b.updatedAt) - parseIsoTimestamp(a.updatedAt),
  )
}

function mergeIncomingAgentMessages(
  existingMessages: ChatMessage[],
  incomingMessages: IncomingAgentMessage[],
): ChatMessage[] {
  const dedupedExisting: ChatMessage[] = []
  for (const existing of existingMessages) {
    if (existing.role !== "assistant") {
      dedupedExisting.push(existing)
      continue
    }
    const prevIdx = dedupedExisting.findIndex((m) => m.role === "assistant" && m.id === existing.id)
    if (prevIdx === -1) {
      dedupedExisting.push(existing)
      continue
    }
    dedupedExisting[prevIdx] = {
      ...dedupedExisting[prevIdx],
      content: `${dedupedExisting[prevIdx].content}${existing.content}`,
      createdAt: existing.createdAt,
      source: existing.source || dedupedExisting[prevIdx].source,
      sender: existing.sender || dedupedExisting[prevIdx].sender,
    }
  }

  const mergedMessages = dedupedExisting
  for (const am of incomingMessages) {
    const normalizedSource: ChatMessage["source"] =
      am.source === "hud" || am.source === "agent" || am.source === "voice"
        ? am.source
        : "agent"
    const incoming: ChatMessage = {
      id: am.id,
      role: am.role,
      content: am.content,
      createdAt: new Date(am.ts).toISOString(),
      source: normalizedSource,
      sender: am.sender,
      ...(typeof am.nlpCleanText === "string" ? { nlpCleanText: am.nlpCleanText } : {}),
      ...(typeof am.nlpConfidence === "number" ? { nlpConfidence: am.nlpConfidence } : {}),
      ...(typeof am.nlpCorrectionCount === "number" ? { nlpCorrectionCount: am.nlpCorrectionCount } : {}),
      ...(am.nlpBypass ? { nlpBypass: true } : {}),
    }

    if (incoming.role === "assistant") {
      const existingIdx = mergedMessages.findIndex((m) => m.role === "assistant" && m.id === incoming.id)
      if (existingIdx !== -1) {
        const existing = mergedMessages[existingIdx]
        mergedMessages[existingIdx] = {
          ...existing,
          content: `${existing.content}${incoming.content}`,
          createdAt: incoming.createdAt,
          source: incoming.source || existing.source,
          sender: incoming.sender || existing.sender,
        }
        continue
      }

      const lastIdx = mergedMessages.length - 1
      const last = mergedMessages[lastIdx]
      if (last?.role === "assistant" && last.id === incoming.id) {
        mergedMessages[lastIdx] = {
          ...last,
          content: `${last.content}${incoming.content}`,
          createdAt: incoming.createdAt,
          ...(incoming.source ? { source: incoming.source } : {}),
          ...(incoming.sender ? { sender: incoming.sender } : {}),
        }
        continue
      }

      mergedMessages.push(incoming)
      continue
    }

    const incomingTrimmed = incoming.content.trim()
    if (incomingTrimmed && incoming.source === "hud") {
      let lastUserIdx = -1
      for (let i = mergedMessages.length - 1; i >= 0; i -= 1) {
        if (mergedMessages[i]?.role === "user") {
          lastUserIdx = i
          break
        }
      }
      const lastUser = lastUserIdx >= 0 ? mergedMessages[lastUserIdx] : null
      if (lastUser && lastUser.content.trim() === incomingTrimmed) {
        const incomingTs = parseIsoTimestamp(incoming.createdAt)
        const lastUserTs = parseIsoTimestamp(lastUser.createdAt)
        if (Math.abs(incomingTs - lastUserTs) <= USER_ECHO_DEDUP_MS) {
          // Keep one visible user bubble but hydrate it with NLP metadata from
          // the HUD echo event.
          mergedMessages[lastUserIdx] = {
            ...lastUser,
            ...(typeof incoming.nlpCleanText === "string" ? { nlpCleanText: incoming.nlpCleanText } : {}),
            ...(typeof incoming.nlpConfidence === "number" ? { nlpConfidence: incoming.nlpConfidence } : {}),
            ...(typeof incoming.nlpCorrectionCount === "number" ? { nlpCorrectionCount: incoming.nlpCorrectionCount } : {}),
            ...(incoming.nlpBypass ? { nlpBypass: true } : {}),
          }
          continue
        }
      }
    }

    mergedMessages.push(incoming)
  }

  return mergedMessages
}

export interface UseConversationsOptions {
  agentConnected: boolean
  agentMessages: IncomingAgentMessage[]
  clearAgentMessages: () => void
}

export interface UseConversationsReturn {
  conversations: Conversation[]
  activeConvo: Conversation | null
  isLoaded: boolean
  mergedCountRef: React.MutableRefObject<number>
  sendMessage: (content: string, sendToAgent: (content: string, voiceEnabled: boolean, ttsVoice: string, meta: Record<string, unknown>) => void) => Promise<void>
  handleNewChat: () => void
  handleSelectConvo: (id: string) => Promise<void>
  handleDeleteConvo: (id: string) => Promise<void>
  handleRenameConvo: (id: string, title: string) => void
  handleArchiveConvo: (id: string, archived: boolean) => void
  handlePinConvo: (id: string, pinned: boolean) => void
  addUserMessage: (content: string) => Conversation | null
}

export function useConversations({
  agentConnected,
  agentMessages,
  clearAgentMessages,
}: UseConversationsOptions): UseConversationsReturn {
  const router = useRouter()
  const searchParams = useSearchParams()
  const shouldOpenPendingNovaChat = searchParams.get("open") === "novachat"

  const [conversations, setConversations] = useState<Conversation[]>([])
  const [activeConvo, setActiveConvo] = useState<Conversation | null>(null)
  const [isLoaded, setIsLoaded] = useState(false)

  const mergedCountRef = useRef(0)
  const syncTimersRef = useRef<Map<string, number>>(new Map())
  const pendingMessagesInFlightRef = useRef(false)

  // Server API functions
  const fetchConversationsFromServer = useCallback(async (): Promise<Conversation[]> => {
    const res = await fetch("/api/threads", { cache: "no-store" })
    const data = await res.json().catch(() => ({})) as { conversations?: Conversation[] }
    if (!res.ok) throw new Error("Failed to load conversations.")
    return Array.isArray(data.conversations) ? data.conversations : []
  }, [])

  const createServerConversation = useCallback(async (): Promise<Conversation> => {
    const res = await fetch("/api/threads", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: DEFAULT_CONVERSATION_TITLE }),
    })
    const data = await res.json().catch(() => ({})) as { conversation?: Conversation; error?: string }
    if (!res.ok || !data.conversation) throw new Error(data.error || "Failed to create conversation.")
    return data.conversation
  }, [])

  const patchServerConversation = useCallback(async (id: string, patch: { title?: string; pinned?: boolean; archived?: boolean }) => {
    const res = await fetch(`/api/threads/${encodeURIComponent(id)}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(patch),
    })
    if (!res.ok) throw new Error("Failed to update conversation.")
  }, [])

  const deleteServerConversation = useCallback(async (id: string) => {
    const res = await fetch(`/api/threads/${encodeURIComponent(id)}`, {
      method: "DELETE",
    })
    if (!res.ok) throw new Error("Failed to delete conversation.")
  }, [])

  const syncServerMessages = useCallback(async (convo: Conversation) => {
    await fetch(`/api/threads/${encodeURIComponent(convo.id)}/messages`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ messages: convo.messages }),
    })
  }, [])

  const scheduleServerSync = useCallback((convo: Conversation) => {
    const existing = syncTimersRef.current.get(convo.id)
    if (typeof existing === "number") {
      window.clearTimeout(existing)
    }
    const timer = window.setTimeout(() => {
      syncTimersRef.current.delete(convo.id)
      void syncServerMessages(convo).catch(() => {})
    }, 280)
    syncTimersRef.current.set(convo.id, timer)
  }, [syncServerMessages])

  // Persist conversations
  const persist = useCallback(
    (convos: Conversation[], active: Conversation | null) => {
      setConversations(convos)
      saveConversations(convos)
      writeShellUiCache({ conversations: convos })
      if (active) {
        setActiveConvo(active)
        setActiveId(active.id)
        scheduleServerSync(active)
      }
      if (!active) {
        setActiveConvo(null)
        setActiveId(null)
      }
    },
    [scheduleServerSync],
  )

  // Initial load from cache
  useLayoutEffect(() => {
    const cachedConversations = readShellUiCache().conversations ?? loadConversations()
    if (cachedConversations.length === 0) {
      setIsLoaded(true)
      return
    }
    if (shouldOpenPendingNovaChat) {
      setConversations(cachedConversations)
      setActiveConvo(null)
      setActiveId(null)
      setIsLoaded(true)
      return
    }
    const activeId = getActiveId()
    const activeFromCache =
      (activeId ? cachedConversations.find((c) => c.id === activeId) : null) ?? cachedConversations[0]
    setConversations(cachedConversations)
    setActiveConvo(activeFromCache || null)
    if (activeFromCache) {
      setActiveId(activeFromCache.id)
    }
    setIsLoaded(true)
  }, [shouldOpenPendingNovaChat])

  // Load from server and merge
  useEffect(() => {
    let cancelled = false

    void (async () => {
      try {
        const convos = await fetchConversationsFromServer()
        if (cancelled) return
        const mergedConvos = mergeConversationsPreferLocal(
          readShellUiCache().conversations ?? loadConversations(),
          convos,
        )
        const activeId = getActiveId()
        const found = mergedConvos.find((c) => c.id === activeId)
        if (shouldOpenPendingNovaChat) {
          setConversations(mergedConvos)
          saveConversations(mergedConvos)
          writeShellUiCache({ conversations: mergedConvos })
          setActiveConvo(null)
          setActiveId(null)
          setIsLoaded(true)
          return
        }
        if (found) {
          setConversations(mergedConvos)
          saveConversations(mergedConvos)
          writeShellUiCache({ conversations: mergedConvos })
          setActiveConvo(found)
          setIsLoaded(true)
          return
        }
        if (mergedConvos.length > 0) {
          setConversations(mergedConvos)
          saveConversations(mergedConvos)
          writeShellUiCache({ conversations: mergedConvos })
          setActiveConvo(mergedConvos[0])
          setActiveId(mergedConvos[0].id)
          setIsLoaded(true)
          return
        }
        const fresh = await createServerConversation()
        if (cancelled) return
        setConversations([fresh])
        saveConversations([fresh])
        writeShellUiCache({ conversations: [fresh] })
        setActiveConvo(fresh)
        setActiveId(fresh.id)
        setIsLoaded(true)
      } catch {
        if (cancelled) return
        setConversations([])
        setActiveConvo(null)
        setIsLoaded(true)
      }
    })()

    return () => {
      cancelled = true
    }
  }, [createServerConversation, fetchConversationsFromServer, shouldOpenPendingNovaChat])

  // Process pending NovaChat messages
  const processPendingNovaChatMessages = useCallback(async (): Promise<number> => {
    if (!isLoaded || pendingMessagesInFlightRef.current) return 0
    pendingMessagesInFlightRef.current = true
    try {
      const res = await fetch("/api/novachat/pending", { cache: "no-store" })
      if (!res.ok) return 0
      const data = await res.json() as {
        ok: boolean
        messages?: Array<{
          id: string
          title: string
          content: string
          missionId?: string
          missionLabel?: string
          metadata?: {
            missionRunId?: string
            runKey?: string
            attempt?: number
            source?: "scheduler" | "trigger"
            outputChannel?: string
          }
          createdAt: string
        }>
      }
      if (!data.ok || !Array.isArray(data.messages) || data.messages.length === 0) return 0

      const consumedIds: string[] = []
      let latestConvo: Conversation | null = null
      let updatedConvos = [...conversations]

      for (const msg of data.messages) {
        const newConvo = await createServerConversation().catch(() => null)
        if (!newConvo) continue

        const assistantMsg: ChatMessage = {
          id: generateId(),
          role: "assistant",
          content: msg.content,
          createdAt: msg.createdAt || new Date().toISOString(),
          source: "agent",
          sender: msg.missionLabel || "Nova Mission",
          missionId: msg.missionId,
          missionLabel: msg.missionLabel,
          missionRunId: msg.metadata?.missionRunId,
          missionRunKey: msg.metadata?.runKey,
          missionAttempt:
            Number.isFinite(Number(msg.metadata?.attempt || 0)) && Number(msg.metadata?.attempt || 0) > 0
              ? Number(msg.metadata?.attempt || 0)
              : undefined,
          missionSource: msg.metadata?.source,
          missionOutputChannel: msg.metadata?.outputChannel,
        }

        const convoWithMessage: Conversation = {
          ...newConvo,
          title: msg.title || msg.missionLabel || "Mission Report",
          messages: [assistantMsg],
          updatedAt: new Date().toISOString(),
        }

        const synced = await syncServerMessages(convoWithMessage).then(() => true).catch(() => false)
        if (!synced) continue

        consumedIds.push(msg.id)
        updatedConvos = [convoWithMessage, ...updatedConvos.filter((c) => c.id !== convoWithMessage.id)]
        latestConvo = convoWithMessage
      }

      if (latestConvo) {
        persist(updatedConvos, latestConvo)
      }

      if (consumedIds.length > 0) {
        await fetch("/api/novachat/pending", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ messageIds: consumedIds }),
        }).catch(() => {})
      }
      return consumedIds.length
    } catch {
      return 0
    } finally {
      pendingMessagesInFlightRef.current = false
    }
  }, [isLoaded, conversations, createServerConversation, syncServerMessages, persist])

  // Poll for pending messages
  useEffect(() => {
    if (!isLoaded) return
    void processPendingNovaChatMessages()
    const intervalId = window.setInterval(() => {
      void processPendingNovaChatMessages()
    }, 15000)
    return () => {
      window.clearInterval(intervalId)
    }
  }, [isLoaded, processPendingNovaChatMessages])

  // Handle pending nova chat redirect
  useEffect(() => {
    if (!isLoaded) return
    if (!shouldOpenPendingNovaChat) return
    let attempts = 0
    const maxAttempts = 40
    void (async () => {
      const consumed = await processPendingNovaChatMessages()
      if (consumed > 0) {
        router.replace("/chat")
      }
    })()
    const intervalId = window.setInterval(() => {
      void (async () => {
        const consumed = await processPendingNovaChatMessages()
        if (consumed > 0 || attempts >= maxAttempts) {
          window.clearInterval(intervalId)
          router.replace("/chat")
          return
        }
        attempts += 1
      })()
    }, 250)
    return () => {
      window.clearInterval(intervalId)
    }
  }, [isLoaded, processPendingNovaChatMessages, router, shouldOpenPendingNovaChat])

  // Merge agent messages into their origin conversation.
  useEffect(() => {
    if (agentMessages.length <= mergedCountRef.current) return

    const newOnes = agentMessages.slice(mergedCountRef.current)
    mergedCountRef.current = agentMessages.length
    if (newOnes.length === 0 || conversations.length === 0) return

    const incomingByConversation = new Map<string, IncomingAgentMessage[]>()
    for (const item of newOnes) {
      const explicitConversationId =
        typeof item.conversationId === "string" ? item.conversationId.trim() : ""
      const targetConversationId = explicitConversationId || String(activeConvo?.id || "").trim()
      if (!targetConversationId) continue
      const bucket = incomingByConversation.get(targetConversationId)
      if (bucket) {
        bucket.push(item)
      } else {
        incomingByConversation.set(targetConversationId, [item])
      }
    }
    if (incomingByConversation.size === 0) return

    const existingById = new Map(conversations.map((convo) => [convo.id, convo]))
    const changedById = new Map<string, Conversation>()
    const convos = conversations.map((convo) => {
      const incoming = incomingByConversation.get(convo.id)
      if (!incoming || incoming.length === 0) return convo

      const mergedMessages = mergeIncomingAgentMessages(convo.messages, incoming)
      const updated: Conversation = {
        ...convo,
        messages: mergedMessages,
        updatedAt: new Date().toISOString(),
        title: resolveConversationTitle({
          messages: mergedMessages,
          currentTitle: convo.title,
          conversations,
          conversationId: convo.id,
        }),
      }
      changedById.set(updated.id, updated)
      return updated
    })
    if (changedById.size === 0) return

    const nextActive = activeConvo ? convos.find((c) => c.id === activeConvo.id) ?? activeConvo : null
    persist(convos, nextActive)

    for (const updated of changedById.values()) {
      scheduleServerSync(updated)
      const previous = existingById.get(updated.id)
      if (previous && updated.title !== previous.title) {
        void patchServerConversation(updated.id, { title: updated.title }).catch(() => {})
      }
    }
  }, [agentMessages, activeConvo, conversations, patchServerConversation, persist, scheduleServerSync])

  // Cleanup sync timer
  useEffect(() => {
    return () => {
      for (const timer of syncTimersRef.current.values()) {
        window.clearTimeout(timer)
      }
      syncTimersRef.current.clear()
    }
  }, [])

  // Handlers
  const handleNewChat = useCallback(() => {
    router.push("/home")
  }, [router])

  const handleSelectConvo = useCallback(
    async (id: string) => {
      let found = conversations.find((c) => c.id === id)
      if (!found) {
        const remote = await fetchConversationsFromServer().catch(() => [])
        if (remote.length > 0) {
          const merged = mergeConversationsPreferLocal(conversations, remote)
          setConversations(merged)
          saveConversations(merged)
          writeShellUiCache({ conversations: merged })
          found = merged.find((c) => c.id === id)
        }
      }
      if (found) {
        setActiveConvo(found)
        setActiveId(found.id)
      }
    },
    [conversations, fetchConversationsFromServer],
  )

  const handleDeleteConvo = useCallback(
    async (id: string) => {
      await deleteServerConversation(id).catch(() => {})
      const remaining = conversations.filter((c) => c.id !== id)

      if (activeConvo?.id === id) {
        clearAgentMessages()
        mergedCountRef.current = 0

        if (remaining.length > 0) {
          persist(remaining, remaining[0])
        } else {
          const fresh = await createServerConversation().catch(() => null)
          if (!fresh) {
            setConversations([])
            setActiveConvo(null)
            setActiveId(null)
            return
          }
          persist([fresh], fresh)
        }
      } else {
        persist(remaining, activeConvo)
      }
    },
    [conversations, activeConvo, clearAgentMessages, createServerConversation, deleteServerConversation, persist],
  )

  const handleRenameConvo = useCallback(
    (id: string, title: string) => {
      const trimmed = title.trim()
      if (!trimmed) return
      void patchServerConversation(id, { title: trimmed }).catch(() => {})
      const next = conversations.map((c) =>
        c.id === id ? { ...c, title: trimmed, updatedAt: new Date().toISOString() } : c,
      )
      const nextActive = activeConvo ? next.find((c) => c.id === activeConvo.id) ?? activeConvo : null
      persist(next, nextActive)
    },
    [conversations, activeConvo, patchServerConversation, persist],
  )

  const handleArchiveConvo = useCallback(
    (id: string, archived: boolean) => {
      void patchServerConversation(id, { archived }).catch(() => {})
      const next = conversations.map((c) =>
        c.id === id ? { ...c, archived, updatedAt: new Date().toISOString() } : c,
      )

      if (activeConvo?.id === id && archived) {
        const fallback = next.find((c) => !c.archived && c.id !== id) ?? next.find((c) => c.id !== id) ?? null
        persist(next, fallback)
        return
      }

      const nextActive = activeConvo ? next.find((c) => c.id === activeConvo.id) ?? activeConvo : null
      persist(next, nextActive)
    },
    [conversations, activeConvo, patchServerConversation, persist],
  )

  const handlePinConvo = useCallback(
    (id: string, pinned: boolean) => {
      void patchServerConversation(id, { pinned }).catch(() => {})
      const next = conversations.map((c) => (c.id === id ? { ...c, pinned } : c))
      const nextActive = activeConvo ? next.find((c) => c.id === activeConvo.id) ?? activeConvo : null
      persist(next, nextActive)
    },
    [conversations, activeConvo, patchServerConversation, persist],
  )

  const addUserMessage = useCallback(
    (content: string): Conversation | null => {
      if (!content.trim() || !activeConvo) return null

      const userMsg: ChatMessage = {
        id: generateId(),
        role: "user",
        content: content.trim(),
        createdAt: new Date().toISOString(),
        source: "agent",
      }

      const updated: Conversation = {
        ...activeConvo,
        messages: [...activeConvo.messages, userMsg],
        updatedAt: new Date().toISOString(),
        title: resolveConversationTitle({
          messages: [...activeConvo.messages, userMsg],
          currentTitle: activeConvo.title,
          conversations,
          conversationId: activeConvo.id,
        }),
      }

      const convos = conversations.map((c) => (c.id === updated.id ? updated : c))
      persist(convos, updated)
      if (updated.title !== activeConvo.title) {
        void patchServerConversation(updated.id, { title: updated.title }).catch(() => {})
      }

      return updated
    },
    [activeConvo, conversations, patchServerConversation, persist],
  )

  const sendMessage = useCallback(
    async (
      content: string,
      sendToAgent: (content: string, voiceEnabled: boolean, ttsVoice: string, meta: Record<string, unknown>) => void,
    ) => {
      if (!content.trim() || !agentConnected || !activeConvo) return

      const updatedConvo = addUserMessage(content)
      const lastMessage = updatedConvo?.messages?.[updatedConvo.messages.length - 1]
      const localMessageId = lastMessage?.role === "user" ? String(lastMessage.id || "") : ""

      const { loadUserSettings } = await import("@/lib/settings/userSettings")
      const { getActiveUserId } = await import("@/lib/auth/active-user")
      const settings = loadUserSettings()
      const activeUserId = getActiveUserId()
      if (!activeUserId) return
      sendToAgent(content.trim(), settings.app.voiceEnabled, settings.app.ttsVoice, {
        conversationId: activeConvo.id,
        sender: "hud-user",
        messageId: localMessageId,
        userId: activeUserId,
        assistantName: settings.personalization.assistantName,
        communicationStyle: settings.personalization.communicationStyle,
        tone: settings.personalization.tone,
      })
    },
    [activeConvo, agentConnected, addUserMessage],
  )

  return {
    conversations,
    activeConvo,
    isLoaded,
    mergedCountRef,
    sendMessage,
    handleNewChat,
    handleSelectConvo,
    handleDeleteConvo,
    handleRenameConvo,
    handleArchiveConvo,
    handlePinConvo,
    addUserMessage,
  }
}

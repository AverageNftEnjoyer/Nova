"use client"

import { useState, useEffect, useLayoutEffect, useCallback, useRef } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import {
  type Conversation,
  type ChatMessage,
  generateId,
  getActiveId,
  isAutoGeneratedConversationTitle,
  loadConversations,
  saveConversations,
  setActiveId,
  DEFAULT_CONVERSATION_TITLE,
  resolveConversationTitle,
} from "@/lib/chat/conversations"
import { readShellUiCache, writeShellUiCache } from "@/lib/settings/shell-ui-cache"
import { ACTIVE_USER_CHANGED_EVENT, getActiveUserId } from "@/lib/auth/active-user"
import {
  buildPendingPollScopeKey,
  computeBackoffDelayMs,
  defaultPollIntervalMs,
  parseRetryAfterMs,
} from "@/lib/novachat/polling-resilience"

function parseIsoTimestamp(value: string | undefined): number {
  const ts = Date.parse(String(value || ""))
  return Number.isFinite(ts) ? ts : 0
}

function normalizeMessageComparableText(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
}

function normalizeMessageComparableCompact(value: string): string {
  return normalizeMessageComparableText(value).replace(/[^a-z0-9]+/g, "")
}

function areLikelySameMessage(local: ChatMessage, server: ChatMessage): boolean {
  if (!local || !server) return false
  if (local.role !== server.role) return false
  const localText = normalizeMessageComparableText(local.content)
  const serverText = normalizeMessageComparableText(server.content)
  if (!localText || !serverText) return false
  if (localText === serverText) return true
  const localCompact = normalizeMessageComparableCompact(local.content)
  const serverCompact = normalizeMessageComparableCompact(server.content)
  if (!localCompact || !serverCompact) return false
  if (localCompact === serverCompact) return true
  if (localCompact.includes(serverCompact) || serverCompact.includes(localCompact)) {
    const smaller = Math.min(localCompact.length, serverCompact.length)
    const larger = Math.max(localCompact.length, serverCompact.length)
    return smaller / Math.max(1, larger) >= 0.72
  }
  return false
}

function stabilizeServerMessageIds(localMessages: ChatMessage[], serverMessages: ChatMessage[]): ChatMessage[] {
  if (!Array.isArray(localMessages) || !Array.isArray(serverMessages)) return serverMessages
  if (localMessages.length === 0 || serverMessages.length === 0) return serverMessages

  const usedLocalIndexes = new Set<number>()
  const usedOutputIds = new Set<string>()
  const localIndexById = new Map<string, number>()
  for (let i = 0; i < localMessages.length; i += 1) {
    const localId = String(localMessages[i]?.id || "").trim()
    if (localId && !localIndexById.has(localId)) localIndexById.set(localId, i)
  }

  const claimLocalIndex = (index: number): ChatMessage | null => {
    if (index < 0 || index >= localMessages.length) return null
    if (usedLocalIndexes.has(index)) return null
    usedLocalIndexes.add(index)
    return localMessages[index]
  }

  const pickMatchingLocal = (serverMessage: ChatMessage, serverIndex: number): ChatMessage | null => {
    const serverId = String(serverMessage?.id || "").trim()
    if (serverId) {
      const exact = localIndexById.get(serverId)
      if (typeof exact === "number") {
        const claimed = claimLocalIndex(exact)
        if (claimed) return claimed
      }
    }

    const sameIndex = claimLocalIndex(serverIndex)
    if (sameIndex && areLikelySameMessage(sameIndex, serverMessage)) return sameIndex
    if (sameIndex && !areLikelySameMessage(sameIndex, serverMessage)) {
      usedLocalIndexes.delete(serverIndex)
    }

    const windowStart = Math.max(0, serverIndex - 2)
    const windowEnd = Math.min(localMessages.length - 1, serverIndex + 2)
    for (let i = windowStart; i <= windowEnd; i += 1) {
      if (usedLocalIndexes.has(i)) continue
      if (!areLikelySameMessage(localMessages[i], serverMessage)) continue
      const claimed = claimLocalIndex(i)
      if (claimed) return claimed
    }

    for (let i = 0; i < localMessages.length; i += 1) {
      if (usedLocalIndexes.has(i)) continue
      if (!areLikelySameMessage(localMessages[i], serverMessage)) continue
      const claimed = claimLocalIndex(i)
      if (claimed) return claimed
    }

    return null
  }

  return serverMessages.map((serverMessage, serverIndex) => {
    const matchedLocal = pickMatchingLocal(serverMessage, serverIndex)
    const candidateId = String(matchedLocal?.id || serverMessage.id || "").trim()
    if (!candidateId || usedOutputIds.has(candidateId)) {
      const fallbackId = String(serverMessage.id || "").trim()
      if (fallbackId) usedOutputIds.add(fallbackId)
      return { ...serverMessage, id: fallbackId || candidateId || `msg-${serverIndex}` }
    }
    usedOutputIds.add(candidateId)
    return { ...serverMessage, id: candidateId }
  })
}

const USER_ECHO_DEDUP_MS = 15_000
const ASSISTANT_ECHO_DEDUP_MS = 60_000
/** Local optimistic ids from home are generateId() format. */
const OPTIMISTIC_ID_REGEX = /^\d+-[a-z0-9]+$/
const MISSION_SPAM_COOLDOWN_MS = 30_000
const MISSION_INFLIGHT_MAX_MS = 90_000
const PENDING_POLL_LEASE_TTL_MS = 12_000
const PENDING_POLL_LEASE_STORAGE_KEY = "nova_pending_poll_lease_v1"

function normalizeMissionPromptSignature(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 260)
}

function isLikelyMissionPrompt(value: string): boolean {
  const text = normalizeMissionPromptSignature(value)
  if (!text) return false
  return /\b(mission|workflow|automation|schedule|scheduled|remind|reminder|every day|daily|weekday)\b/.test(text)
}

function buildMissionScopeKey(userContextId: string, sessionConversationId: string): string {
  const user = String(userContextId || "").trim().toLowerCase() || "anonymous"
  const convo = String(sessionConversationId || "").trim().toLowerCase() || "none"
  return `mission:${user}:${convo}`
}

function normalizeMessageSignature(value: string): string {
  return String(value || "")
    .toLowerCase()
    .replace(/[\u200B-\u200D\uFEFF]/g, "")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 220)
}

function firstUserMessageSignature(convo: Conversation): string {
  const firstUser = convo.messages.find((m) => m.role === "user" && String(m.content || "").trim().length > 0)
  return normalizeMessageSignature(String(firstUser?.content || ""))
}

function normalizeTitleSignature(value: string): string {
  return String(value || "").toLowerCase().replace(/\s+/g, " ").trim()
}

function isLikelyOptimisticDuplicate(localConvo: Conversation, remoteConvo: Conversation): boolean {
  if (!OPTIMISTIC_ID_REGEX.test(localConvo.id) || OPTIMISTIC_ID_REGEX.test(remoteConvo.id)) return false

  const localUserSig = firstUserMessageSignature(localConvo)
  const remoteUserSig = firstUserMessageSignature(remoteConvo)
  if (localUserSig || remoteUserSig) {
    if (!(localUserSig && remoteUserSig)) return false
    if (localUserSig === remoteUserSig) return true
    const localContainsRemote = localUserSig.length > 18 && localUserSig.startsWith(remoteUserSig)
    const remoteContainsLocal = remoteUserSig.length > 18 && remoteUserSig.startsWith(localUserSig)
    return localContainsRemote || remoteContainsLocal
  }

  const localTitle = normalizeTitleSignature(localConvo.title)
  const remoteTitle = normalizeTitleSignature(remoteConvo.title)
  if (!localTitle || !remoteTitle || localTitle !== remoteTitle) return false

  const localUpdated = parseIsoTimestamp(localConvo.updatedAt)
  const remoteUpdated = parseIsoTimestamp(remoteConvo.updatedAt)
  return Math.abs(localUpdated - remoteUpdated) <= 3 * 60 * 1000
}

type IncomingAgentMessage = {
  id: string
  role: "user" | "assistant"
  content: string
  ts: number
  source?: string
  sender?: string
  conversationId?: string
  nlpCleanText?: string
  nlpConfidence?: number
  nlpCorrectionCount?: number
  nlpBypass?: boolean
}

type PendingMissionMessage = {
  id: string
  title: string
  content: string
  missionId?: string
  missionLabel?: string
  metadata?: {
    missionRunId?: string
    runKey?: string
    attempt?: number
    source?: "scheduler" | "trigger"
    outputChannel?: string
    deliveryKey?: string
  }
  createdAt: string
}

function resolvePendingMissionGroupKey(msg: PendingMissionMessage): string {
  const deliveryKey = String(msg.metadata?.deliveryKey || "").trim()
  if (deliveryKey) {
    const deliveryParts = deliveryKey.split(":")
    if (deliveryParts.length >= 2) {
      return `run:${deliveryParts[0]}:${deliveryParts[1]}`
    }
  }
  const missionId = String(msg.missionId || "").trim() || "mission"
  const missionRunId = String(msg.metadata?.missionRunId || "").trim()
  const runKey = String(msg.metadata?.runKey || "").trim()
  if (missionRunId) return `run:${missionId}:${missionRunId}`
  if (runKey) return `run:${missionId}:${runKey}`
  return `message:${msg.id}`
}

function resolvePendingMissionDeliveryKey(msg: PendingMissionMessage): string {
  const explicit = String(msg.metadata?.deliveryKey || "").trim()
  if (explicit) return explicit
  const missionId = String(msg.missionId || "").trim() || "mission"
  const missionRunId = String(msg.metadata?.missionRunId || "").trim()
  const runKey = String(msg.metadata?.runKey || "").trim()
  const contentSig = normalizeMessageComparableCompact(String(msg.content || "")).slice(0, 80) || "content"
  return `fallback:${missionId}:${missionRunId || runKey || "run"}:${contentSig}`
}

function mergeConversationsPreferLocal(
  local: Conversation[],
  remote: Conversation[],
  optimisticIdToServerId: Map<string, string> = new Map<string, string>(),
): Conversation[] {
  if (local.length === 0) return remote
  if (remote.length === 0) return local

  const localById = new Map(local.map((entry) => [entry.id, entry]))
  const mappedLocalByServerId = new Map<string, Conversation>()
  for (const localConvo of local) {
    const mappedServerId = optimisticIdToServerId.get(localConvo.id)
    if (!mappedServerId) continue
    if (localById.has(mappedServerId)) continue
    if (!mappedLocalByServerId.has(mappedServerId)) {
      mappedLocalByServerId.set(mappedServerId, localConvo)
    }
  }
  const merged = remote.map((serverConvo) => {
    const localConvo = localById.get(serverConvo.id) || mappedLocalByServerId.get(serverConvo.id)
    if (!localConvo) return serverConvo

    const localUpdated = parseIsoTimestamp(localConvo.updatedAt)
    const serverUpdated = parseIsoTimestamp(serverConvo.updatedAt)
    const localLooksNewer =
      localConvo.messages.length > serverConvo.messages.length || localUpdated > serverUpdated
    if (!localLooksNewer) {
      return {
        ...serverConvo,
        messages: stabilizeServerMessageIds(localConvo.messages, serverConvo.messages),
      }
    }

    return {
      ...serverConvo,
      title:
        localConvo.title && !isAutoGeneratedConversationTitle(localConvo.title) ? localConvo.title : serverConvo.title,
      messages: localConvo.messages,
      updatedAt: localUpdated >= serverUpdated ? localConvo.updatedAt : serverConvo.updatedAt,
      pinned: localConvo.pinned ?? serverConvo.pinned,
      archived: localConvo.archived ?? serverConvo.archived,
    }
  })

  const remoteIds = new Set(remote.map((entry) => entry.id))
  const localOnly = local.filter((entry) => {
    if (remoteIds.has(entry.id)) return false
    const mappedServerId = optimisticIdToServerId.get(entry.id)
    if (mappedServerId && remoteIds.has(mappedServerId)) return false
    if (!OPTIMISTIC_ID_REGEX.test(entry.id)) return true
    for (const remoteEntry of remote) {
      if (isLikelyOptimisticDuplicate(entry, remoteEntry)) return false
    }
    return true
  })
  return [...merged, ...localOnly].sort(
    (a, b) => parseIsoTimestamp(b.updatedAt) - parseIsoTimestamp(a.updatedAt),
  )
}

function mergeIncomingAgentMessages(
  existingMessages: ChatMessage[],
  incomingMessages: IncomingAgentMessage[],
): ChatMessage[] {
  const normalizeComparableText = (value: string): string =>
    String(value || "")
      .toLowerCase()
      .replace(/[\u200B-\u200D\uFEFF]/g, "")
      .replace(/\s+/g, " ")
      .trim()

  const shouldPreferIncomingAssistantVersion = (base: string, incoming: string): boolean => {
    const left = normalizeComparableText(base)
    const right = normalizeComparableText(incoming)
    if (!left || !right) return false
    if (left === right) return true

    const leftCompact = left.replace(/[^a-z0-9]+/g, "")
    const rightCompact = right.replace(/[^a-z0-9]+/g, "")
    if (!leftCompact || !rightCompact) return false
    if (rightCompact.includes(leftCompact)) return true
    if (leftCompact.includes(rightCompact)) return false

    const leftWords = new Set(left.split(/\s+/g).filter(Boolean))
    const rightWords = new Set(right.split(/\s+/g).filter(Boolean))
    if (leftWords.size < 8 || rightWords.size < 8) return false
    let overlap = 0
    for (const word of leftWords) {
      if (rightWords.has(word)) overlap += 1
    }
    const smaller = Math.min(leftWords.size, rightWords.size)
    const overlapRatio = smaller > 0 ? overlap / smaller : 0
    const lenRatio = Math.min(leftCompact.length, rightCompact.length) / Math.max(leftCompact.length, rightCompact.length)
    return overlapRatio >= 0.82 && lenRatio >= 0.62
  }

  const mergeAssistantContent = (base: string, incoming: string): string => {
    const left = String(base || "")
    const right = String(incoming || "")
    if (!right) return left
    if (!left) return right
    if (shouldPreferIncomingAssistantVersion(left, right)) {
      return right.length >= left.length ? right : left
    }
    if (right.length >= left.length && right.startsWith(left)) return right
    if (left.length >= right.length && left.startsWith(right)) return left
    if (left.endsWith(right)) return left
    if (right.endsWith(left)) return right
    return `${left}${right}`
  }

  const dedupedExisting: ChatMessage[] = []
  for (const existing of existingMessages) {
    if (existing.role !== "assistant") {
      dedupedExisting.push(existing)
      continue
    }
    const prevIdx = dedupedExisting.findIndex((m) => m.role === "assistant" && m.id === existing.id)
    if (prevIdx === -1) {
      dedupedExisting.push(existing)
      continue
    }
    dedupedExisting[prevIdx] = {
      ...dedupedExisting[prevIdx],
      content: mergeAssistantContent(dedupedExisting[prevIdx].content, existing.content),
      createdAt: existing.createdAt,
      source: existing.source || dedupedExisting[prevIdx].source,
      sender: existing.sender || dedupedExisting[prevIdx].sender,
    }
  }

  const mergedMessages = dedupedExisting
  for (const am of incomingMessages) {
    const normalizedSource: ChatMessage["source"] =
      am.source === "hud" || am.source === "agent" || am.source === "voice"
        ? am.source
        : "agent"
    const incoming: ChatMessage = {
      id: am.id,
      role: am.role,
      content: am.content,
      createdAt: new Date(am.ts).toISOString(),
      source: normalizedSource,
      sender: am.sender,
      ...(typeof am.nlpCleanText === "string" ? { nlpCleanText: am.nlpCleanText } : {}),
      ...(typeof am.nlpConfidence === "number" ? { nlpConfidence: am.nlpConfidence } : {}),
      ...(typeof am.nlpCorrectionCount === "number" ? { nlpCorrectionCount: am.nlpCorrectionCount } : {}),
      ...(am.nlpBypass ? { nlpBypass: true } : {}),
    }

    if (incoming.role === "assistant") {
      const existingIdx = mergedMessages.findIndex((m) => m.role === "assistant" && m.id === incoming.id)
      if (existingIdx !== -1) {
        const existing = mergedMessages[existingIdx]
        mergedMessages[existingIdx] = {
          ...existing,
          content: mergeAssistantContent(existing.content, incoming.content),
          createdAt: incoming.createdAt,
          source: incoming.source || existing.source,
          sender: incoming.sender || existing.sender,
        }
        continue
      }

      const lastIdx = mergedMessages.length - 1
      const last = mergedMessages[lastIdx]
      if (last?.role === "assistant" && last.id === incoming.id) {
        mergedMessages[lastIdx] = {
          ...last,
          content: mergeAssistantContent(last.content, incoming.content),
          createdAt: incoming.createdAt,
          ...(incoming.source ? { source: incoming.source } : {}),
          ...(incoming.sender ? { sender: incoming.sender } : {}),
        }
        continue
      }

      // Backend can emit a final assistant "message" event right after stream completion.
      // If it matches the just-rendered assistant bubble, merge it instead of appending a duplicate.
      if (last?.role === "assistant") {
        const incomingTs = parseIsoTimestamp(incoming.createdAt)
        const lastTs = parseIsoTimestamp(last.createdAt)
        const closeInTime = Math.abs(incomingTs - lastTs) <= ASSISTANT_ECHO_DEDUP_MS
        const sameText = normalizeComparableText(last.content) === normalizeComparableText(incoming.content)
        const semanticallySame =
          shouldPreferIncomingAssistantVersion(last.content, incoming.content)
          || shouldPreferIncomingAssistantVersion(incoming.content, last.content)
        if (closeInTime && (sameText || semanticallySame)) {
          mergedMessages[lastIdx] = {
            ...last,
            content: mergeAssistantContent(last.content, incoming.content),
            createdAt: incomingTs >= lastTs ? incoming.createdAt : last.createdAt,
            source: incoming.source || last.source,
            sender: incoming.sender || last.sender,
          }
          continue
        }
      }

      mergedMessages.push(incoming)
      continue
    }

    const incomingTrimmed = incoming.content.trim()
    if (incomingTrimmed && incoming.source === "hud") {
      let lastUserIdx = -1
      for (let i = mergedMessages.length - 1; i >= 0; i -= 1) {
        if (mergedMessages[i]?.role === "user") {
          lastUserIdx = i
          break
        }
      }
      const lastUser = lastUserIdx >= 0 ? mergedMessages[lastUserIdx] : null
      if (lastUser && lastUser.content.trim() === incomingTrimmed) {
        const incomingTs = parseIsoTimestamp(incoming.createdAt)
        const lastUserTs = parseIsoTimestamp(lastUser.createdAt)
        if (Math.abs(incomingTs - lastUserTs) <= USER_ECHO_DEDUP_MS) {
          // Keep one visible user bubble but hydrate it with NLP metadata from
          // the HUD echo event.
          mergedMessages[lastUserIdx] = {
            ...lastUser,
            ...(typeof incoming.nlpCleanText === "string" ? { nlpCleanText: incoming.nlpCleanText } : {}),
            ...(typeof incoming.nlpConfidence === "number" ? { nlpConfidence: incoming.nlpConfidence } : {}),
            ...(typeof incoming.nlpCorrectionCount === "number" ? { nlpCorrectionCount: incoming.nlpCorrectionCount } : {}),
            ...(incoming.nlpBypass ? { nlpBypass: true } : {}),
          }
          continue
        }
      }
    }

    mergedMessages.push(incoming)
  }

  return mergedMessages
}

export interface UseConversationsOptions {
  agentConnected: boolean
  agentMessages: IncomingAgentMessage[]
  clearAgentMessages: () => void
}

export interface UseConversationsReturn {
  conversations: Conversation[]
  activeConvo: Conversation | null
  isLoaded: boolean
  mergedCountRef: React.MutableRefObject<number>
  sendMessage: (content: string, sendToAgent: (content: string, voiceEnabled: boolean, ttsVoice: string, meta: Record<string, unknown>) => void) => Promise<void>
  handleNewChat: () => void
  handleSelectConvo: (id: string) => Promise<void>
  handleDeleteConvo: (id: string) => Promise<void>
  handleRenameConvo: (id: string, title: string) => void
  handleArchiveConvo: (id: string, archived: boolean) => void
  handlePinConvo: (id: string, pinned: boolean) => void
  addUserMessage: (content: string) => Conversation | null
  ensureServerConversationForOptimistic: (convo: Conversation) => Promise<void>
  resolveConversationIdForAgent: (conversationId: string) => string
  resolveSessionConversationIdForAgent: (conversationId: string) => string
  pendingQueueStatus: {
    mode: "idle" | "processing" | "retrying"
    message: string
    retryInSeconds: number
  }
}

export function useConversations({
  agentConnected,
  agentMessages,
  clearAgentMessages,
}: UseConversationsOptions): UseConversationsReturn {
  const router = useRouter()
  const searchParams = useSearchParams()
  const shouldOpenPendingNovaChat = searchParams.get("open") === "novachat"

  const [conversations, setConversations] = useState<Conversation[]>([])
  const [activeConvo, setActiveConvo] = useState<Conversation | null>(null)
  const [isLoaded, setIsLoaded] = useState(false)

  const mergedCountRef = useRef(0)
  const syncTimersRef = useRef<Map<string, number>>(new Map())
  const pendingMessagesInFlightRef = useRef(false)
  const pendingPollPromiseRef = useRef<Promise<number> | null>(null)
  const pendingPollAbortRef = useRef<AbortController | null>(null)
  const pendingPollBackoffTimerRef = useRef<number | null>(null)
  const pendingRedirectTimerRef = useRef<number | null>(null)
  const pendingPollBackoffAttemptsRef = useRef(0)
  const pendingPollScopeKeyRef = useRef("")
  const pendingMissionConversationByGroupRef = useRef<Map<string, string>>(new Map())
  const pendingPollTabIdRef = useRef(`tab-${Math.random().toString(36).slice(2, 10)}`)
  const activeUserIdRef = useRef("")
  const missionInFlightByScopeRef = useRef<Map<string, { signature: string; startedAt: number; cooldownUntil: number }>>(new Map())
  const [pendingQueueStatus, setPendingQueueStatus] = useState<{
    mode: "idle" | "processing" | "retrying"
    message: string
    retryAtMs: number
  }>({
    mode: "idle",
    message: "",
    retryAtMs: 0,
  })
  const setPendingQueueStatusSafe = useCallback((next: { mode: "idle" | "processing" | "retrying"; message: string; retryAtMs: number }) => {
    setPendingQueueStatus((prev) => {
      if (prev.mode === next.mode && prev.message === next.message && prev.retryAtMs === next.retryAtMs) return prev
      return next
    })
  }, [])
  const processedAgentMessageKeysRef = useRef<Set<string>>(new Set())
  /** When we replace an optimistic convo with server convo, agent replies may still use the old id; route them to the server convo */
  const optimisticIdToServerIdRef = useRef<Map<string, string>>(new Map())
  /** Keep runtime session continuity when optimistic chat ids are replaced with server ids. */
  const sessionConversationIdByConversationIdRef = useRef<Map<string, string>>(new Map())
  const optimisticEnsureInFlightRef = useRef<Set<string>>(new Set())
  const latestConversationsRef = useRef<Conversation[]>([])
  const latestActiveConvoIdRef = useRef<string>("")
  latestConversationsRef.current = conversations
  latestActiveConvoIdRef.current = String(activeConvo?.id || "").trim()

  useEffect(() => {
    const updateActiveUser = () => {
      activeUserIdRef.current = String(getActiveUserId() || "").trim()
    }
    updateActiveUser()
    window.addEventListener(ACTIVE_USER_CHANGED_EVENT, updateActiveUser as EventListener)
    return () => {
      window.removeEventListener(ACTIVE_USER_CHANGED_EVENT, updateActiveUser as EventListener)
    }
  }, [])

  // Server API functions
  const fetchConversationsFromServer = useCallback(async (): Promise<Conversation[]> => {
    const res = await fetch("/api/threads", { cache: "no-store" })
    const data = await res.json().catch(() => ({})) as { conversations?: Conversation[] }
    if (!res.ok) throw new Error("Failed to load conversations.")
    return Array.isArray(data.conversations) ? data.conversations : []
  }, [])

  const createServerConversation = useCallback(async (title?: string): Promise<Conversation> => {
    const res = await fetch("/api/threads", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ title: (title && String(title).trim()) || DEFAULT_CONVERSATION_TITLE }),
    })
    const data = await res.json().catch(() => ({})) as { conversation?: Conversation; error?: string }
    if (!res.ok || !data.conversation) throw new Error(data.error || "Failed to create conversation.")
    return data.conversation
  }, [])

  const patchServerConversation = useCallback(async (id: string, patch: { title?: string; pinned?: boolean; archived?: boolean }) => {
    const res = await fetch(`/api/threads/${encodeURIComponent(id)}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(patch),
    })
    if (!res.ok) throw new Error("Failed to update conversation.")
  }, [])

  const deleteServerConversation = useCallback(async (id: string) => {
    const res = await fetch(`/api/threads/${encodeURIComponent(id)}`, {
      method: "DELETE",
    })
    if (!res.ok) throw new Error("Failed to delete conversation.")
  }, [])

  const syncServerMessages = useCallback(async (convo: Conversation): Promise<boolean> => {
    const mappedId = optimisticIdToServerIdRef.current.get(convo.id)
    const targetId = mappedId || convo.id
    if (OPTIMISTIC_ID_REGEX.test(targetId)) return false

    const res = await fetch(`/api/threads/${encodeURIComponent(targetId)}/messages`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ messages: convo.messages }),
    })
    return res.ok
  }, [])

  const resolveConversationIdForAgent = useCallback((conversationId: string): string => {
    const normalized = String(conversationId || "").trim()
    if (!normalized) return ""
    return optimisticIdToServerIdRef.current.get(normalized) || normalized
  }, [])

  const resolveSessionConversationIdForAgent = useCallback((conversationId: string): string => {
    const normalized = String(conversationId || "").trim()
    if (!normalized) return ""
    return sessionConversationIdByConversationIdRef.current.get(normalized) || normalized
  }, [])

  useEffect(() => {
    if (pendingQueueStatus.mode !== "retrying") return
    const tick = window.setInterval(() => {
      setPendingQueueStatus((prev) => {
        if (prev.mode !== "retrying") return prev
        if (prev.retryAtMs <= Date.now()) return { mode: "processing", message: "Retrying pending queue...", retryAtMs: 0 }
        return { ...prev }
      })
    }, 250)
    return () => window.clearInterval(tick)
  }, [pendingQueueStatus.mode])

  const tryAcquirePendingPollLease = useCallback((scopeKey: string): boolean => {
    if (typeof window === "undefined") return true
    const nowMs = Date.now()
    const holder = String(pendingPollTabIdRef.current || "").trim()
    if (!holder || !scopeKey) return true
    try {
      const raw = localStorage.getItem(PENDING_POLL_LEASE_STORAGE_KEY)
      if (raw) {
        const parsed = JSON.parse(raw) as { scopeKey?: string; holder?: string; expiresAt?: number }
        const existingScope = String(parsed.scopeKey || "").trim()
        const existingHolder = String(parsed.holder || "").trim()
        const expiresAt = Number(parsed.expiresAt || 0)
        if (existingScope === scopeKey && existingHolder && existingHolder !== holder && expiresAt > nowMs) {
          return false
        }
      }
      const next = {
        scopeKey,
        holder,
        expiresAt: nowMs + PENDING_POLL_LEASE_TTL_MS,
      }
      localStorage.setItem(PENDING_POLL_LEASE_STORAGE_KEY, JSON.stringify(next))
      const confirmRaw = localStorage.getItem(PENDING_POLL_LEASE_STORAGE_KEY)
      if (!confirmRaw) return false
      const confirm = JSON.parse(confirmRaw) as { scopeKey?: string; holder?: string; expiresAt?: number }
      return (
        String(confirm.scopeKey || "").trim() === scopeKey
        && String(confirm.holder || "").trim() === holder
        && Number(confirm.expiresAt || 0) > nowMs
      )
    } catch {
      // If storage is unavailable, fall back to single-tab runtime guards.
      return true
    }
  }, [])

  const releasePendingPollLease = useCallback((scopeKey: string): void => {
    if (typeof window === "undefined") return
    const holder = String(pendingPollTabIdRef.current || "").trim()
    if (!holder || !scopeKey) return
    try {
      const raw = localStorage.getItem(PENDING_POLL_LEASE_STORAGE_KEY)
      if (!raw) return
      const parsed = JSON.parse(raw) as { scopeKey?: string; holder?: string; expiresAt?: number }
      if (String(parsed.scopeKey || "").trim() !== scopeKey) return
      if (String(parsed.holder || "").trim() !== holder) return
      localStorage.removeItem(PENDING_POLL_LEASE_STORAGE_KEY)
    } catch {
    }
  }, [])

  useEffect(() => {
    return () => {
      releasePendingPollLease(String(pendingPollScopeKeyRef.current || ""))
      if (pendingPollBackoffTimerRef.current !== null) {
        window.clearTimeout(pendingPollBackoffTimerRef.current)
        pendingPollBackoffTimerRef.current = null
      }
      if (pendingRedirectTimerRef.current !== null) {
        window.clearTimeout(pendingRedirectTimerRef.current)
        pendingRedirectTimerRef.current = null
      }
      pendingPollAbortRef.current?.abort()
      pendingPollAbortRef.current = null
      pendingPollPromiseRef.current = null
    }
  }, [releasePendingPollLease])

  useEffect(() => {
    const nextScopeKey = buildPendingPollScopeKey(
      activeUserIdRef.current,
      resolveSessionConversationIdForAgent(activeConvo?.id || ""),
    )
    if (pendingPollScopeKeyRef.current && pendingPollScopeKeyRef.current !== nextScopeKey) {
      releasePendingPollLease(String(pendingPollScopeKeyRef.current || ""))
      pendingPollAbortRef.current?.abort()
      pendingPollAbortRef.current = null
      pendingPollPromiseRef.current = null
      pendingMessagesInFlightRef.current = false
      setPendingQueueStatus((prev) => (prev.mode === "idle" ? prev : { mode: "idle", message: "", retryAtMs: 0 }))
    }
    pendingPollScopeKeyRef.current = nextScopeKey
  }, [activeConvo?.id, resolveSessionConversationIdForAgent, releasePendingPollLease])

  const reconcileOptimisticConversationMappings = useCallback(
    (localConvos: Conversation[], remoteConvos: Conversation[]) => {
      if (!Array.isArray(localConvos) || !Array.isArray(remoteConvos)) return
      if (localConvos.length === 0 || remoteConvos.length === 0) return

      const optimisticMap = optimisticIdToServerIdRef.current
      const sessionMap = sessionConversationIdByConversationIdRef.current

      for (const localConvo of localConvos) {
        const localId = String(localConvo?.id || "").trim()
        if (!OPTIMISTIC_ID_REGEX.test(localId)) continue

        const existingServerId = optimisticMap.get(localId)
        if (existingServerId) {
          const canonicalSessionId = sessionMap.get(localId) || localId
          sessionMap.set(localId, canonicalSessionId)
          sessionMap.set(existingServerId, canonicalSessionId)
          continue
        }

        const matchedServerConvo = remoteConvos.find((remoteConvo) =>
          isLikelyOptimisticDuplicate(localConvo, remoteConvo),
        )
        if (!matchedServerConvo) continue

        optimisticMap.set(localId, matchedServerConvo.id)
        const canonicalSessionId = sessionMap.get(localId) || localId
        sessionMap.set(localId, canonicalSessionId)
        sessionMap.set(matchedServerConvo.id, canonicalSessionId)
      }
    },
    [],
  )

  const resolveConversationSelectionId = useCallback(
    (conversationId: string, availableConversations: Conversation[] = conversations): string => {
      const normalized = String(conversationId || "").trim()
      if (!normalized) return ""

      const availableIds = new Set(availableConversations.map((entry) => String(entry.id || "").trim()))
      if (availableIds.has(normalized)) return normalized

      const mappedServerId = optimisticIdToServerIdRef.current.get(normalized)
      if (mappedServerId && availableIds.has(mappedServerId)) return mappedServerId

      for (const [optimisticId, serverId] of optimisticIdToServerIdRef.current.entries()) {
        if (serverId === normalized && availableIds.has(optimisticId)) return optimisticId
      }

      return mappedServerId || normalized
    },
    [conversations],
  )

  const scheduleServerSync = useCallback((convo: Conversation) => {
    const existing = syncTimersRef.current.get(convo.id)
    if (typeof existing === "number") {
      window.clearTimeout(existing)
    }
    const scheduledConvoId = convo.id
    const timer = window.setTimeout(() => {
      syncTimersRef.current.delete(scheduledConvoId)
      const mappedId = optimisticIdToServerIdRef.current.get(scheduledConvoId)
      const latestConversations = latestConversationsRef.current
      const latestMapped = mappedId
        ? latestConversations.find((entry) => entry.id === mappedId)
        : null
      const latestByOriginal = latestConversations.find((entry) => entry.id === scheduledConvoId)
      const latestToSync = latestMapped || latestByOriginal || convo

      if (mappedId && OPTIMISTIC_ID_REGEX.test(scheduledConvoId) && !latestMapped && !latestByOriginal) {
        // Optimistic thread has already been replaced; avoid syncing stale snapshots.
        return
      }

      void syncServerMessages(latestToSync).catch(() => {})
    }, 280)
    syncTimersRef.current.set(convo.id, timer)
  }, [syncServerMessages])

  // Persist conversations
  const persist = useCallback(
    (convos: Conversation[], active: Conversation | null) => {
      setConversations(convos)
      saveConversations(convos)
      writeShellUiCache({ conversations: convos })
      if (active) {
        setActiveConvo(active)
        setActiveId(active.id)
        scheduleServerSync(active)
      }
      if (!active) {
        setActiveConvo(null)
        setActiveId(null)
      }
    },
    [scheduleServerSync],
  )

  // Initial load from cache
  useLayoutEffect(() => {
    const cachedConversations = readShellUiCache().conversations ?? loadConversations()
    if (cachedConversations.length === 0) {
      setIsLoaded(true)
      return
    }
    if (shouldOpenPendingNovaChat) {
      const activeId = getActiveId()
      const activeFromCache =
        (activeId ? cachedConversations.find((c) => c.id === activeId) : null) ?? cachedConversations[0]
      setConversations(cachedConversations)
      setActiveConvo(activeFromCache || null)
      if (activeFromCache) setActiveId(activeFromCache.id)
      setIsLoaded(true)
      return
    }
    const activeId = getActiveId()
    const activeFromCache =
      (activeId ? cachedConversations.find((c) => c.id === activeId) : null) ?? cachedConversations[0]
    setConversations(cachedConversations)
    setActiveConvo(activeFromCache || null)
    if (activeFromCache) {
      setActiveId(activeFromCache.id)
    }
    setIsLoaded(true)
  }, [shouldOpenPendingNovaChat])

  // Load from server and merge
  useEffect(() => {
    let cancelled = false

    void (async () => {
      try {
        const convos = await fetchConversationsFromServer()
        if (cancelled) return
        const localSnapshot = readShellUiCache().conversations ?? loadConversations()
        reconcileOptimisticConversationMappings(localSnapshot, convos)
        const mergedConvos = mergeConversationsPreferLocal(localSnapshot, convos, optimisticIdToServerIdRef.current)
        const activeId = getActiveId()
        const selectedActiveId = resolveConversationSelectionId(activeId || "", mergedConvos)
        const found = mergedConvos.find((c) => c.id === selectedActiveId)
        if (shouldOpenPendingNovaChat) {
          const fallbackActiveId = getActiveId()
          const fallbackActive =
            (fallbackActiveId ? mergedConvos.find((c) => c.id === fallbackActiveId) : null) ?? mergedConvos[0] ?? null
          setConversations(mergedConvos)
          saveConversations(mergedConvos)
          writeShellUiCache({ conversations: mergedConvos })
          setActiveConvo(fallbackActive)
          if (fallbackActive) setActiveId(fallbackActive.id)
          setIsLoaded(true)
          return
        }
        if (found) {
          setConversations(mergedConvos)
          saveConversations(mergedConvos)
          writeShellUiCache({ conversations: mergedConvos })
          setActiveConvo(found)
          if (selectedActiveId && activeId !== selectedActiveId) {
            setActiveId(selectedActiveId)
          }
          setIsLoaded(true)
          return
        }
        if (mergedConvos.length > 0) {
          setConversations(mergedConvos)
          saveConversations(mergedConvos)
          writeShellUiCache({ conversations: mergedConvos })
          setActiveConvo(mergedConvos[0])
          setActiveId(mergedConvos[0].id)
          setIsLoaded(true)
          return
        }
        const fresh = await createServerConversation()
        if (cancelled) return
        setConversations([fresh])
        saveConversations([fresh])
        writeShellUiCache({ conversations: [fresh] })
        setActiveConvo(fresh)
        setActiveId(fresh.id)
        setIsLoaded(true)
      } catch {
        if (cancelled) return
        // Keep existing state (e.g. optimistic convo from home) so the user's message doesn't disappear
        const fallback = readShellUiCache().conversations ?? loadConversations()
        if (fallback.length > 0) {
          const activeId = getActiveId()
          const found = fallback.find((c) => c.id === activeId) ?? fallback[0]
          setConversations(fallback)
          setActiveConvo(found)
          setActiveId(found.id)
        } else {
          setConversations([])
          setActiveConvo(null)
        }
        setIsLoaded(true)
      }
    })()

    return () => {
      cancelled = true
    }
  }, [createServerConversation, fetchConversationsFromServer, reconcileOptimisticConversationMappings, resolveConversationSelectionId, shouldOpenPendingNovaChat])

  // Process pending NovaChat messages
  const processPendingNovaChatMessages = useCallback(async (): Promise<number> => {
    if (!isLoaded) return 0
    if (pendingPollPromiseRef.current) return pendingPollPromiseRef.current
    if (pendingMessagesInFlightRef.current) return 0
    pendingMessagesInFlightRef.current = true
    const pollScopeKey = buildPendingPollScopeKey(
      activeUserIdRef.current,
      resolveSessionConversationIdForAgent(activeConvo?.id || ""),
    )
    pendingPollScopeKeyRef.current = pollScopeKey
    if (!tryAcquirePendingPollLease(pollScopeKey)) {
      pendingMessagesInFlightRef.current = false
      return 0
    }
    const controller = new AbortController()
    pendingPollAbortRef.current = controller
    const run = (async () => {
      try {
        setPendingQueueStatus((prev) => (prev.mode === "idle" ? { mode: "processing", message: "Checking pending queue...", retryAtMs: 0 } : prev))
        const res = await fetch("/api/novachat/pending", {
          cache: "no-store",
          signal: controller.signal,
        })
        if (res.status === 429) {
          const body = await res.json().catch(() => ({})) as { retryAfterMs?: number }
          const retryAfterMs = Math.max(
            parseRetryAfterMs(res.headers.get("Retry-After"), Number(body?.retryAfterMs || 0)),
            defaultPollIntervalMs(),
          )
          pendingPollBackoffAttemptsRef.current += 1
          const delay = computeBackoffDelayMs({
            attempt: pendingPollBackoffAttemptsRef.current,
            retryAfterMs,
          })
          setPendingQueueStatusSafe({
            mode: "retrying",
            message: "Pending queue rate-limited. Retrying shortly.",
            retryAtMs: Date.now() + delay,
          })
          if (pendingPollBackoffTimerRef.current !== null) window.clearTimeout(pendingPollBackoffTimerRef.current)
          pendingPollBackoffTimerRef.current = window.setTimeout(() => {
            pendingPollBackoffTimerRef.current = null
            void processPendingNovaChatMessages()
          }, delay)
          return 0
        }
        if (!res.ok) {
          pendingPollBackoffAttemptsRef.current += 1
          const delay = computeBackoffDelayMs({ attempt: pendingPollBackoffAttemptsRef.current })
          setPendingQueueStatusSafe({
            mode: "retrying",
            message: "Pending queue temporarily unavailable. Retrying.",
            retryAtMs: Date.now() + delay,
          })
          if (pendingPollBackoffTimerRef.current !== null) window.clearTimeout(pendingPollBackoffTimerRef.current)
          pendingPollBackoffTimerRef.current = window.setTimeout(() => {
            pendingPollBackoffTimerRef.current = null
            void processPendingNovaChatMessages()
          }, delay)
          return 0
        }
        pendingPollBackoffAttemptsRef.current = 0
        setPendingQueueStatus((prev) => (prev.mode === "idle" ? prev : { mode: "idle", message: "", retryAtMs: 0 }))
        const data = await res.json() as {
          ok: boolean
          messages?: PendingMissionMessage[]
        }
        if (!data.ok || !Array.isArray(data.messages) || data.messages.length === 0) return 0

        const consumedIds: string[] = []
        let latestConvo: Conversation | null = null
        let updatedConvos = [...conversations]
        const seenDeliveryKeys = new Set<string>()
        const runConversationByGroup = pendingMissionConversationByGroupRef.current
        const sortedMessages = [...data.messages].sort((a, b) => parseIsoTimestamp(a.createdAt) - parseIsoTimestamp(b.createdAt))

        for (const msg of sortedMessages) {
          const deliveryKey = resolvePendingMissionDeliveryKey(msg)
          if (seenDeliveryKeys.has(deliveryKey)) {
            consumedIds.push(msg.id)
            continue
          }
          seenDeliveryKeys.add(deliveryKey)
          const groupKey = resolvePendingMissionGroupKey(msg)
          const existingByGroupId = runConversationByGroup.get(groupKey)
          const missionRunId = String(msg.metadata?.missionRunId || "").trim()
          const missionRunKey = String(msg.metadata?.runKey || "").trim()
          let targetConvo =
            (existingByGroupId ? updatedConvos.find((c) => c.id === existingByGroupId) : null)
            || (missionRunId
              ? updatedConvos.find((c) => c.messages.some((m) => String(m.missionRunId || "").trim() === missionRunId))
              : null)
            || (missionRunKey
              ? updatedConvos.find((c) => c.messages.some((m) => String(m.missionRunKey || "").trim() === missionRunKey))
              : null)
            || null
          if (!targetConvo) {
            targetConvo = await createServerConversation(msg.title || msg.missionLabel || "Mission Report").catch(() => null)
            if (!targetConvo) continue
          }

          const assistantMsg: ChatMessage = {
            id: generateId(),
            role: "assistant",
            content: msg.content,
            createdAt: msg.createdAt || new Date().toISOString(),
            source: "agent",
            sender: msg.missionLabel || "Nova Mission",
            missionId: msg.missionId,
            missionLabel: msg.missionLabel,
            missionRunId: msg.metadata?.missionRunId,
            missionRunKey: msg.metadata?.runKey,
            missionAttempt:
              Number.isFinite(Number(msg.metadata?.attempt || 0)) && Number(msg.metadata?.attempt || 0) > 0
                ? Number(msg.metadata?.attempt || 0)
                : undefined,
            missionSource: msg.metadata?.source,
            missionOutputChannel: msg.metadata?.outputChannel,
          }

          const alreadyPresent = targetConvo.messages.some((existing) => {
            if (existing.role !== "assistant") return false
            if (String(existing.missionRunId || "").trim() !== missionRunId) return false
            return normalizeMessageComparableCompact(String(existing.content || "")) === normalizeMessageComparableCompact(String(msg.content || ""))
          })
          if (alreadyPresent) {
            consumedIds.push(msg.id)
            runConversationByGroup.set(groupKey, targetConvo.id)
            continue
          }

          const convoWithMessage: Conversation = {
            ...targetConvo,
            title: targetConvo.title || msg.title || msg.missionLabel || "Mission Report",
            messages: [...targetConvo.messages, assistantMsg],
            updatedAt: new Date().toISOString(),
          }

          const synced = await syncServerMessages(convoWithMessage).then(() => true).catch(() => false)
          if (!synced) continue

          consumedIds.push(msg.id)
          updatedConvos = [convoWithMessage, ...updatedConvos.filter((c) => c.id !== convoWithMessage.id)]
          latestConvo = convoWithMessage
          runConversationByGroup.set(groupKey, convoWithMessage.id)
        }

        if (latestConvo) {
          persist(updatedConvos, latestConvo)
        }

        if (consumedIds.length > 0) {
          await fetch("/api/novachat/pending", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ messageIds: consumedIds }),
          }).catch(() => {})
        }
        return consumedIds.length
      } catch {
        pendingPollBackoffAttemptsRef.current += 1
        const delay = computeBackoffDelayMs({ attempt: pendingPollBackoffAttemptsRef.current })
        setPendingQueueStatusSafe({
          mode: "retrying",
          message: "Pending queue error. Retrying.",
          retryAtMs: Date.now() + delay,
        })
        if (pendingPollBackoffTimerRef.current !== null) window.clearTimeout(pendingPollBackoffTimerRef.current)
        pendingPollBackoffTimerRef.current = window.setTimeout(() => {
          pendingPollBackoffTimerRef.current = null
          void processPendingNovaChatMessages()
        }, delay)
        return 0
      } finally {
        pendingMessagesInFlightRef.current = false
        pendingPollAbortRef.current = null
        pendingPollPromiseRef.current = null
      }
    })()
    pendingPollPromiseRef.current = run
    return run
  }, [
    isLoaded,
    activeConvo,
    conversations,
    createServerConversation,
    syncServerMessages,
    persist,
    resolveSessionConversationIdForAgent,
    setPendingQueueStatusSafe,
    tryAcquirePendingPollLease,
  ])

  // Poll for pending messages
  useEffect(() => {
    if (!isLoaded) return
    if (shouldOpenPendingNovaChat) return
    void processPendingNovaChatMessages()
    const intervalId = window.setInterval(() => {
      void processPendingNovaChatMessages()
    }, Math.max(5000, defaultPollIntervalMs() * 4))
    return () => {
      window.clearInterval(intervalId)
    }
  }, [isLoaded, processPendingNovaChatMessages, shouldOpenPendingNovaChat])

  // Handle pending nova chat redirect
  useEffect(() => {
    if (!isLoaded) return
    if (!shouldOpenPendingNovaChat) return
    let attempts = 0
    let cancelled = false
    const maxAttempts = 20
    const scheduleNext = (delayMs: number) => {
      if (cancelled) return
      if (pendingRedirectTimerRef.current !== null) window.clearTimeout(pendingRedirectTimerRef.current)
      pendingRedirectTimerRef.current = window.setTimeout(() => {
        pendingRedirectTimerRef.current = null
        void runPoll()
      }, delayMs)
    }
    const runPoll = async () => {
      if (cancelled) return
      const consumed = await processPendingNovaChatMessages()
      if (consumed > 0 || attempts >= maxAttempts) {
        router.replace("/chat")
        return
      }
      attempts += 1
      const delayMs = computeBackoffDelayMs({
        attempt: pendingPollBackoffAttemptsRef.current,
        baseMs: defaultPollIntervalMs(),
      })
      scheduleNext(Math.max(defaultPollIntervalMs(), delayMs))
    }
    void runPoll()
    return () => {
      cancelled = true
      if (pendingRedirectTimerRef.current !== null) {
        window.clearTimeout(pendingRedirectTimerRef.current)
        pendingRedirectTimerRef.current = null
      }
    }
  }, [isLoaded, processPendingNovaChatMessages, router, shouldOpenPendingNovaChat])

  // Merge agent messages into their origin conversation.
  useEffect(() => {
    if (agentMessages.length === 0) {
      mergedCountRef.current = 0
      processedAgentMessageKeysRef.current.clear()
      return
    }

    const processedKeys = processedAgentMessageKeysRef.current

    const makeMergeKey = (item: IncomingAgentMessage): string => {
      const normalizedConversationId = typeof item.conversationId === "string" ? item.conversationId.trim() : ""
      const content = String(item.content || "")
      const head = content.slice(0, 32)
      const tail = content.slice(-32)
      return [
        item.id,
        item.role,
        normalizedConversationId,
        String(item.ts || 0),
        String(content.length),
        head,
        tail,
      ].join("|")
    }

    const newOnes: IncomingAgentMessage[] = []
    for (const item of agentMessages) {
      const key = makeMergeKey(item)
      if (processedKeys.has(key)) continue
      processedKeys.add(key)
      newOnes.push(item)
    }

    if (processedKeys.size > 8000) {
      const compacted = new Set<string>()
      const recent = agentMessages.slice(-400)
      for (const item of recent) compacted.add(makeMergeKey(item))
      processedAgentMessageKeysRef.current = compacted
    }

    mergedCountRef.current = agentMessages.length
    if (newOnes.length === 0 || conversations.length === 0) return

    const incomingByConversation = new Map<string, IncomingAgentMessage[]>()
    const conversationIds = new Set(conversations.map((c) => c.id))
    const activeConversationId = String(activeConvo?.id || "").trim()
    const resolveIncomingConversationId = (rawConversationId: string): string => {
      const normalized = String(rawConversationId || "").trim()
      if (!normalized) {
        if (activeConversationId && conversationIds.has(activeConversationId)) return activeConversationId
        return ""
      }

      const equivalentIds: string[] = [normalized]
      const mappedServerId = optimisticIdToServerIdRef.current.get(normalized)
      if (mappedServerId && !equivalentIds.includes(mappedServerId)) equivalentIds.push(mappedServerId)
      for (const [optimisticId, serverId] of optimisticIdToServerIdRef.current.entries()) {
        if (serverId !== normalized) continue
        if (!equivalentIds.includes(optimisticId)) equivalentIds.push(optimisticId)
      }

      if (
        activeConversationId &&
        equivalentIds.includes(activeConversationId) &&
        conversationIds.has(activeConversationId)
      ) {
        return activeConversationId
      }

      for (const candidate of equivalentIds) {
        if (!conversationIds.has(candidate)) continue
        if (OPTIMISTIC_ID_REGEX.test(candidate)) return candidate
      }
      for (const candidate of equivalentIds) {
        if (conversationIds.has(candidate)) return candidate
      }
      if (activeConversationId && conversationIds.has(activeConversationId)) return activeConversationId
      return ""
    }
    for (const item of newOnes) {
      const explicitConversationId =
        typeof item.conversationId === "string" ? item.conversationId.trim() : ""
      const targetConversationId = resolveIncomingConversationId(explicitConversationId || activeConversationId)
      if (!targetConversationId) continue
      const bucket = incomingByConversation.get(targetConversationId)
      if (bucket) {
        bucket.push(item)
      } else {
        incomingByConversation.set(targetConversationId, [item])
      }
    }
    if (incomingByConversation.size === 0) return

    const existingById = new Map(conversations.map((convo) => [convo.id, convo]))
    const changedById = new Map<string, Conversation>()
    const convos = conversations.map((convo) => {
      const incoming = incomingByConversation.get(convo.id)
      if (!incoming || incoming.length === 0) return convo

      const mergedMessages = mergeIncomingAgentMessages(convo.messages, incoming)
      const updated: Conversation = {
        ...convo,
        messages: mergedMessages,
        updatedAt: new Date().toISOString(),
        title: resolveConversationTitle({
          messages: mergedMessages,
          currentTitle: convo.title,
          conversations,
          conversationId: convo.id,
        }),
      }
      changedById.set(updated.id, updated)
      return updated
    })
    if (changedById.size === 0) return

    const userContextId = String(activeUserIdRef.current || "").trim()
    for (const [conversationId, incoming] of incomingByConversation.entries()) {
      if (!incoming.some((item) => item.role === "assistant")) continue
      const sessionConversationId = resolveSessionConversationIdForAgent(conversationId)
      const missionScopeKey = buildMissionScopeKey(userContextId, sessionConversationId)
      missionInFlightByScopeRef.current.delete(missionScopeKey)
    }

    const nextActive = activeConvo ? convos.find((c) => c.id === activeConvo.id) ?? activeConvo : null
    persist(convos, nextActive)

    for (const updated of changedById.values()) {
      scheduleServerSync(updated)
      const previous = existingById.get(updated.id)
      if (previous && updated.title !== previous.title) {
        void patchServerConversation(updated.id, { title: updated.title }).catch(() => {})
      }
    }
  }, [agentMessages, activeConvo, conversations, patchServerConversation, persist, scheduleServerSync, resolveSessionConversationIdForAgent])

  // Cleanup sync timer
  useEffect(() => {
    const syncTimers = syncTimersRef.current
    return () => {
      for (const timer of syncTimers.values()) {
        window.clearTimeout(timer)
      }
      syncTimers.clear()
    }
  }, [])

  // Handlers
  const handleNewChat = useCallback(() => {
    router.push("/home")
  }, [router])

  const handleSelectConvo = useCallback(
    async (id: string) => {
      const selectedLocalId = resolveConversationSelectionId(id, conversations)
      let found = conversations.find((c) => c.id === selectedLocalId)
      if (!found) {
        const remote = await fetchConversationsFromServer().catch(() => [])
        if (remote.length > 0) {
          reconcileOptimisticConversationMappings(conversations, remote)
          const merged = mergeConversationsPreferLocal(conversations, remote, optimisticIdToServerIdRef.current)
          setConversations(merged)
          saveConversations(merged)
          writeShellUiCache({ conversations: merged })
          const selectedRemoteId = resolveConversationSelectionId(id, merged)
          found = merged.find((c) => c.id === selectedRemoteId)
        }
      }
      if (found) {
        setActiveConvo(found)
        setActiveId(found.id)
      }
    },
    [conversations, fetchConversationsFromServer, reconcileOptimisticConversationMappings, resolveConversationSelectionId],
  )

  const handleDeleteConvo = useCallback(
    async (id: string) => {
      await deleteServerConversation(id).catch(() => {})
      const remaining = conversations.filter((c) => c.id !== id)

      if (activeConvo?.id === id) {
        clearAgentMessages()
        mergedCountRef.current = 0
        processedAgentMessageKeysRef.current.clear()

        if (remaining.length > 0) {
          persist(remaining, remaining[0])
        } else {
          const fresh = await createServerConversation().catch(() => null)
          if (!fresh) {
            setConversations([])
            setActiveConvo(null)
            setActiveId(null)
            return
          }
          persist([fresh], fresh)
        }
      } else {
        persist(remaining, activeConvo)
      }
      optimisticIdToServerIdRef.current.delete(id)
      sessionConversationIdByConversationIdRef.current.delete(id)
    },
    [conversations, activeConvo, clearAgentMessages, createServerConversation, deleteServerConversation, persist],
  )

  const handleRenameConvo = useCallback(
    (id: string, title: string) => {
      const trimmed = title.trim()
      if (!trimmed) return
      void patchServerConversation(id, { title: trimmed }).catch(() => {})
      const next = conversations.map((c) =>
        c.id === id ? { ...c, title: trimmed, updatedAt: new Date().toISOString() } : c,
      )
      const nextActive = activeConvo ? next.find((c) => c.id === activeConvo.id) ?? activeConvo : null
      persist(next, nextActive)
    },
    [conversations, activeConvo, patchServerConversation, persist],
  )

  const handleArchiveConvo = useCallback(
    (id: string, archived: boolean) => {
      void patchServerConversation(id, { archived }).catch(() => {})
      const next = conversations.map((c) =>
        c.id === id ? { ...c, archived, updatedAt: new Date().toISOString() } : c,
      )

      if (activeConvo?.id === id && archived) {
        const fallback = next.find((c) => !c.archived && c.id !== id) ?? next.find((c) => c.id !== id) ?? null
        persist(next, fallback)
        return
      }

      const nextActive = activeConvo ? next.find((c) => c.id === activeConvo.id) ?? activeConvo : null
      persist(next, nextActive)
    },
    [conversations, activeConvo, patchServerConversation, persist],
  )

  const handlePinConvo = useCallback(
    (id: string, pinned: boolean) => {
      void patchServerConversation(id, { pinned }).catch(() => {})
      const next = conversations.map((c) => (c.id === id ? { ...c, pinned } : c))
      const nextActive = activeConvo ? next.find((c) => c.id === activeConvo.id) ?? activeConvo : null
      persist(next, nextActive)
    },
    [conversations, activeConvo, patchServerConversation, persist],
  )

  const addUserMessage = useCallback(
    (
      content: string,
      options?: {
        sessionConversationId?: string
        sessionKey?: string
      },
    ): Conversation | null => {
      if (!content.trim() || !activeConvo) return null

      const userMsg: ChatMessage = {
        id: generateId(),
        role: "user",
        content: content.trim(),
        createdAt: new Date().toISOString(),
        source: "agent",
        ...(options?.sessionConversationId ? { sessionConversationId: options.sessionConversationId } : {}),
        ...(options?.sessionKey ? { sessionKey: options.sessionKey } : {}),
      }

      const updated: Conversation = {
        ...activeConvo,
        messages: [...activeConvo.messages, userMsg],
        updatedAt: new Date().toISOString(),
        title: resolveConversationTitle({
          messages: [...activeConvo.messages, userMsg],
          currentTitle: activeConvo.title,
          conversations,
          conversationId: activeConvo.id,
        }),
      }

      const convos = conversations.map((c) => (c.id === updated.id ? updated : c))
      persist(convos, updated)
      if (updated.title !== activeConvo.title) {
        const mappedId = optimisticIdToServerIdRef.current.get(updated.id)
        const targetId = mappedId || updated.id
        if (!OPTIMISTIC_ID_REGEX.test(targetId)) {
          void patchServerConversation(targetId, { title: updated.title }).catch(() => {})
        }
      }

      return updated
    },
    [activeConvo, conversations, patchServerConversation, persist],
  )

  const ensureServerConversationForOptimistic = useCallback(
    async (convo: Conversation): Promise<void> => {
      if (!OPTIMISTIC_ID_REGEX.test(convo.id)) return
      if (optimisticIdToServerIdRef.current.has(convo.id)) return
      if (optimisticEnsureInFlightRef.current.has(convo.id)) return
      optimisticEnsureInFlightRef.current.add(convo.id)
      try {
        const serverConvo = await createServerConversation(convo.title)
        optimisticIdToServerIdRef.current.set(convo.id, serverConvo.id)
        const canonicalSessionConversationId = resolveSessionConversationIdForAgent(convo.id) || convo.id
        sessionConversationIdByConversationIdRef.current.set(convo.id, canonicalSessionConversationId)
        sessionConversationIdByConversationIdRef.current.set(serverConvo.id, canonicalSessionConversationId)
        const latest = latestConversationsRef.current.find((c) => c.id === convo.id)
        const messagesToSync = latest?.messages ?? convo.messages
        const withMessages: Conversation = {
          ...serverConvo,
          messages: messagesToSync,
          title: convo.title,
          updatedAt: (latest ?? convo).updatedAt,
          pinned: convo.pinned ?? serverConvo.pinned,
          archived: convo.archived ?? serverConvo.archived,
        }
        const beforeSyncConversations = latestConversationsRef.current
        const existingServerConvo = beforeSyncConversations.find((c) => c.id === serverConvo.id)
        const seededServerConvo: Conversation = {
          ...(existingServerConvo ?? serverConvo),
          ...withMessages,
          messages:
            (existingServerConvo?.messages?.length || 0) > withMessages.messages.length
              ? (existingServerConvo?.messages ?? withMessages.messages)
              : withMessages.messages,
          updatedAt:
            parseIsoTimestamp(existingServerConvo?.updatedAt) > parseIsoTimestamp(withMessages.updatedAt)
              ? (existingServerConvo?.updatedAt ?? withMessages.updatedAt)
              : withMessages.updatedAt,
        }
        const preSyncNext = beforeSyncConversations
          .map((c) => (c.id === convo.id || c.id === serverConvo.id ? seededServerConvo : c))
          .filter((c, index, arr) => arr.findIndex((entry) => entry.id === c.id) === index)
        const latestActiveId = latestActiveConvoIdRef.current
        const preSyncActive = !latestActiveId
          ? null
          : (latestActiveId === convo.id || latestActiveId === serverConvo.id)
            ? seededServerConvo
            : preSyncNext.find((entry) => entry.id === latestActiveId) ?? null
        persist(preSyncNext, preSyncActive)
        const synced = await syncServerMessages(seededServerConvo)
        if (!synced) return
        // Re-read latest so we don't overwrite streamed content that arrived while we were awaiting
        const current = latestConversationsRef.current
        const latestNow = current.find((c) => c.id === serverConvo.id) ?? current.find((c) => c.id === convo.id)
        const candidateMessages = latestNow?.messages ?? seededServerConvo.messages
        const existingInCurrent = latestNow?.messages ?? []
        const totalLen = (m: ChatMessage[]) => m.reduce((sum, msg) => sum + (msg.content?.length ?? 0), 0)
        const useExisting = totalLen(existingInCurrent) > totalLen(candidateMessages)
        const messagesToUse = useExisting ? existingInCurrent : candidateMessages
        const serverConvoWithLatestMessages: Conversation = {
          ...seededServerConvo,
          messages: messagesToUse,
          updatedAt: latestNow?.updatedAt ?? seededServerConvo.updatedAt,
        }
        const next = current
          .map((c) => (c.id === convo.id || c.id === serverConvo.id ? serverConvoWithLatestMessages : c))
          .filter((c, index, arr) => arr.findIndex((entry) => entry.id === c.id) === index)
        const refreshedActiveId = latestActiveConvoIdRef.current
        const nextActive = !refreshedActiveId
          ? null
          : (refreshedActiveId === convo.id || refreshedActiveId === serverConvo.id)
            ? serverConvoWithLatestMessages
            : next.find((entry) => entry.id === refreshedActiveId) ?? null
        persist(next, nextActive)
        // Sync full (possibly streamed) messages to server
        void syncServerMessages(serverConvoWithLatestMessages).catch(() => {})
      } catch {
        // Keep optimistic convo on failure
      } finally {
        optimisticEnsureInFlightRef.current.delete(convo.id)
      }
    },
    [createServerConversation, persist, syncServerMessages, resolveSessionConversationIdForAgent],
  )

  // Old local conversations can survive cache reloads; ensure they get a real server thread id.
  useEffect(() => {
    if (!activeConvo) return
    if (!OPTIMISTIC_ID_REGEX.test(activeConvo.id)) return
    void ensureServerConversationForOptimistic(activeConvo)
  }, [activeConvo, ensureServerConversationForOptimistic])

  const sendMessage = useCallback(
    async (
      content: string,
      sendToAgent: (content: string, voiceEnabled: boolean, ttsVoice: string, meta: Record<string, unknown>) => void,
    ) => {
      if (!content.trim() || !agentConnected || !activeConvo) return

      const { loadUserSettings } = await import("@/lib/settings/userSettings")
      const settings = loadUserSettings()
      const activeUserId = getActiveUserId()
      const sessionConversationId = resolveSessionConversationIdForAgent(activeConvo.id)
      const sessionKey = sessionConversationId
        && activeUserId
        ? `agent:nova:hud:user:${activeUserId}:dm:${sessionConversationId}`
        : ""
      const missionPrompt = isLikelyMissionPrompt(content)
      if (missionPrompt) {
        const nowMs = Date.now()
        const scopeKey = buildMissionScopeKey(activeUserId, sessionConversationId || activeConvo.id)
        const signature = normalizeMissionPromptSignature(content)
        for (const [key, value] of missionInFlightByScopeRef.current.entries()) {
          if (!value) continue
          if (nowMs - Number(value.startedAt || 0) > MISSION_INFLIGHT_MAX_MS) {
            missionInFlightByScopeRef.current.delete(key)
          }
        }
        const existing = missionInFlightByScopeRef.current.get(scopeKey)
        if (
          existing
          && existing.signature === signature
          && nowMs < Number(existing.cooldownUntil || 0)
        ) {
          const activeSnapshot = latestConversationsRef.current.find((entry) => entry.id === activeConvo.id) || activeConvo
          const notice: ChatMessage = {
            id: generateId(),
            role: "assistant",
            content: "Still processing your mission request. I did not send a duplicate. I will update you once it finishes.",
            createdAt: new Date().toISOString(),
            source: "agent",
            sender: "Nova",
          }
          const updated = { ...activeSnapshot, messages: [...activeSnapshot.messages, notice], updatedAt: new Date().toISOString() }
          const nextConvos = latestConversationsRef.current.map((entry) => (entry.id === updated.id ? updated : entry))
          persist(nextConvos, updated)
          return
        }
        missionInFlightByScopeRef.current.set(scopeKey, {
          signature,
          startedAt: nowMs,
          cooldownUntil: nowMs + MISSION_SPAM_COOLDOWN_MS,
        })
      }
      const updatedConvo = addUserMessage(content, {
        ...(sessionConversationId ? { sessionConversationId } : {}),
        ...(sessionKey ? { sessionKey } : {}),
      })
      const lastMessage = updatedConvo?.messages?.[updatedConvo.messages.length - 1]
      const localMessageId = lastMessage?.role === "user" ? String(lastMessage.id || "") : ""
      if (!activeUserId) return
      sendToAgent(content.trim(), settings.app.voiceEnabled, settings.app.ttsVoice, {
        conversationId: resolveConversationIdForAgent(activeConvo.id),
        sender: "hud-user",
        ...(sessionKey ? { sessionKey } : {}),
        messageId: localMessageId,
        userId: activeUserId,
        assistantName: settings.personalization.assistantName,
        communicationStyle: settings.personalization.communicationStyle,
        tone: settings.personalization.tone,
      })
    },
    [activeConvo, agentConnected, addUserMessage, persist, resolveConversationIdForAgent, resolveSessionConversationIdForAgent],
  )

  return {
    conversations,
    activeConvo,
    isLoaded,
    mergedCountRef,
    sendMessage,
    handleNewChat,
    handleSelectConvo,
    handleDeleteConvo,
    handleRenameConvo,
    handleArchiveConvo,
    handlePinConvo,
    addUserMessage,
    ensureServerConversationForOptimistic,
    resolveConversationIdForAgent,
    resolveSessionConversationIdForAgent,
    pendingQueueStatus: {
      mode: pendingQueueStatus.mode,
      message: pendingQueueStatus.message,
      retryInSeconds:
        pendingQueueStatus.mode === "retrying"
          ? Math.max(1, Math.ceil((pendingQueueStatus.retryAtMs - Date.now()) / 1000))
          : 0,
    },
  }
}

